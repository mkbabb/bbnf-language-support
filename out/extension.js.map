{"version":3,"file":"extension.js","sources":["../node_modules/@mkbabb/parse-that/dist/parse.js","../node_modules/@mkbabb/parse-that/dist/ebnf.js","../src/parser.ts","../node_modules/prettier/doc.js","../src/printer.ts","../src/index.ts","../src/extension.ts"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport chalk from \"chalk\";\nvar docExports = {};\nvar doc = {\n  get exports() {\n    return docExports;\n  },\n  set exports(v) {\n    docExports = v;\n  }\n};\n(function(module, exports) {\n  (function(factory) {\n    {\n      module.exports = factory();\n    }\n  })(function() {\n    var __getOwnPropNames = Object.getOwnPropertyNames;\n    var __commonJS = (cb, mod) => function __require() {\n      return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n    };\n    var require_doc_js_umd = __commonJS({\n      \"dist/_doc.js.umd.js\"(exports2, module2) {\n        var __create = Object.create;\n        var __defProp2 = Object.defineProperty;\n        var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n        var __getOwnPropNames2 = Object.getOwnPropertyNames;\n        var __getProtoOf = Object.getPrototypeOf;\n        var __hasOwnProp = Object.prototype.hasOwnProperty;\n        var __esm = (fn, res) => function __init() {\n          return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;\n        };\n        var __commonJS2 = (cb, mod) => function __require() {\n          return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = {\n            exports: {}\n          }).exports, mod), mod.exports;\n        };\n        var __export = (target, all2) => {\n          for (var name in all2)\n            __defProp2(target, name, {\n              get: all2[name],\n              enumerable: true\n            });\n        };\n        var __copyProps = (to, from, except, desc) => {\n          if (from && typeof from === \"object\" || typeof from === \"function\") {\n            for (let key of __getOwnPropNames2(from))\n              if (!__hasOwnProp.call(to, key) && key !== except)\n                __defProp2(to, key, {\n                  get: () => from[key],\n                  enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n                });\n          }\n          return to;\n        };\n        var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, \"default\", {\n          value: mod,\n          enumerable: true\n        }) : target, mod));\n        var __toCommonJS = (mod) => __copyProps(__defProp2({}, \"__esModule\", {\n          value: true\n        }), mod);\n        var init_define_process = __esm({\n          \"<define:process>\"() {\n          }\n        });\n        var require_doc_builders = __commonJS2({\n          \"src/document/doc-builders.js\"(exports22, module22) {\n            init_define_process();\n            function concat(parts) {\n              return {\n                type: \"concat\",\n                parts\n              };\n            }\n            function indent(contents) {\n              return {\n                type: \"indent\",\n                contents\n              };\n            }\n            function align(widthOrString, contents) {\n              return {\n                type: \"align\",\n                contents,\n                n: widthOrString\n              };\n            }\n            function group2(contents) {\n              let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n              return {\n                type: \"group\",\n                id: opts.id,\n                contents,\n                break: Boolean(opts.shouldBreak),\n                expandedStates: opts.expandedStates\n              };\n            }\n            function dedentToRoot(contents) {\n              return align(Number.NEGATIVE_INFINITY, contents);\n            }\n            function markAsRoot(contents) {\n              return align({\n                type: \"root\"\n              }, contents);\n            }\n            function dedent(contents) {\n              return align(-1, contents);\n            }\n            function conditionalGroup(states, opts) {\n              return group2(states[0], Object.assign(Object.assign({}, opts), {}, {\n                expandedStates: states\n              }));\n            }\n            function fill(parts) {\n              return {\n                type: \"fill\",\n                parts\n              };\n            }\n            function ifBreak(breakContents, flatContents) {\n              let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n              return {\n                type: \"if-break\",\n                breakContents,\n                flatContents,\n                groupId: opts.groupId\n              };\n            }\n            function indentIfBreak(contents, opts) {\n              return {\n                type: \"indent-if-break\",\n                contents,\n                groupId: opts.groupId,\n                negate: opts.negate\n              };\n            }\n            function lineSuffix(contents) {\n              return {\n                type: \"line-suffix\",\n                contents\n              };\n            }\n            var lineSuffixBoundary = {\n              type: \"line-suffix-boundary\"\n            };\n            var breakParent = {\n              type: \"break-parent\"\n            };\n            var trim = {\n              type: \"trim\"\n            };\n            var hardlineWithoutBreakParent = {\n              type: \"line\",\n              hard: true\n            };\n            var literallineWithoutBreakParent = {\n              type: \"line\",\n              hard: true,\n              literal: true\n            };\n            var line = {\n              type: \"line\"\n            };\n            var softline = {\n              type: \"line\",\n              soft: true\n            };\n            var hardline = concat([hardlineWithoutBreakParent, breakParent]);\n            var literalline = concat([literallineWithoutBreakParent, breakParent]);\n            var cursor = {\n              type: \"cursor\",\n              placeholder: Symbol(\"cursor\")\n            };\n            function join(sep, arr) {\n              const res = [];\n              for (let i = 0; i < arr.length; i++) {\n                if (i !== 0) {\n                  res.push(sep);\n                }\n                res.push(arr[i]);\n              }\n              return concat(res);\n            }\n            function addAlignmentToDoc(doc2, size, tabWidth) {\n              let aligned = doc2;\n              if (size > 0) {\n                for (let i = 0; i < Math.floor(size / tabWidth); ++i) {\n                  aligned = indent(aligned);\n                }\n                aligned = align(size % tabWidth, aligned);\n                aligned = align(Number.NEGATIVE_INFINITY, aligned);\n              }\n              return aligned;\n            }\n            function label(label2, contents) {\n              return {\n                type: \"label\",\n                label: label2,\n                contents\n              };\n            }\n            module22.exports = {\n              concat,\n              join,\n              line,\n              softline,\n              hardline,\n              literalline,\n              group: group2,\n              conditionalGroup,\n              fill,\n              lineSuffix,\n              lineSuffixBoundary,\n              cursor,\n              breakParent,\n              ifBreak,\n              trim,\n              indent,\n              indentIfBreak,\n              align,\n              addAlignmentToDoc,\n              markAsRoot,\n              dedentToRoot,\n              dedent,\n              hardlineWithoutBreakParent,\n              literallineWithoutBreakParent,\n              label\n            };\n          }\n        });\n        var require_end_of_line = __commonJS2({\n          \"src/common/end-of-line.js\"(exports22, module22) {\n            init_define_process();\n            function guessEndOfLine(text) {\n              const index = text.indexOf(\"\\r\");\n              if (index >= 0) {\n                return text.charAt(index + 1) === \"\\n\" ? \"crlf\" : \"cr\";\n              }\n              return \"lf\";\n            }\n            function convertEndOfLineToChars(value) {\n              switch (value) {\n                case \"cr\":\n                  return \"\\r\";\n                case \"crlf\":\n                  return \"\\r\\n\";\n                default:\n                  return \"\\n\";\n              }\n            }\n            function countEndOfLineChars(text, eol) {\n              let regex2;\n              switch (eol) {\n                case \"\\n\":\n                  regex2 = /\\n/g;\n                  break;\n                case \"\\r\":\n                  regex2 = /\\r/g;\n                  break;\n                case \"\\r\\n\":\n                  regex2 = /\\r\\n/g;\n                  break;\n                default:\n                  throw new Error(`Unexpected \"eol\" ${JSON.stringify(eol)}.`);\n              }\n              const endOfLines = text.match(regex2);\n              return endOfLines ? endOfLines.length : 0;\n            }\n            function normalizeEndOfLine(text) {\n              return text.replace(/\\r\\n?/g, \"\\n\");\n            }\n            module22.exports = {\n              guessEndOfLine,\n              convertEndOfLineToChars,\n              countEndOfLineChars,\n              normalizeEndOfLine\n            };\n          }\n        });\n        var require_get_last = __commonJS2({\n          \"src/utils/get-last.js\"(exports22, module22) {\n            init_define_process();\n            var getLast = (arr) => arr[arr.length - 1];\n            module22.exports = getLast;\n          }\n        });\n        function ansiRegex() {\n          let {\n            onlyFirst = false\n          } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n          const pattern = [\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"].join(\"|\");\n          return new RegExp(pattern, onlyFirst ? void 0 : \"g\");\n        }\n        var init_ansi_regex = __esm({\n          \"node_modules/strip-ansi/node_modules/ansi-regex/index.js\"() {\n            init_define_process();\n          }\n        });\n        function stripAnsi(string2) {\n          if (typeof string2 !== \"string\") {\n            throw new TypeError(`Expected a \\`string\\`, got \\`${typeof string2}\\``);\n          }\n          return string2.replace(ansiRegex(), \"\");\n        }\n        var init_strip_ansi = __esm({\n          \"node_modules/strip-ansi/index.js\"() {\n            init_define_process();\n            init_ansi_regex();\n          }\n        });\n        function isFullwidthCodePoint(codePoint) {\n          if (!Number.isInteger(codePoint)) {\n            return false;\n          }\n          return codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141);\n        }\n        var init_is_fullwidth_code_point = __esm({\n          \"node_modules/is-fullwidth-code-point/index.js\"() {\n            init_define_process();\n          }\n        });\n        var require_emoji_regex = __commonJS2({\n          \"node_modules/emoji-regex/index.js\"(exports22, module22) {\n            init_define_process();\n            module22.exports = function() {\n              return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|(?:\\uD83E\\uDDD1\\uD83C\\uDFFF\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C\\uDFFB(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))?|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC)?|(?:\\uD83D\\uDC69(?:\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC69(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83E\\uDDD1(?:\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDE36\\u200D\\uD83C\\uDF2B|\\uD83C\\uDFF3\\uFE0F\\u200D\\u26A7|\\uD83D\\uDC3B\\u200D\\u2744|(?:(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\uD83C\\uDFF4\\u200D\\u2620|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])\\u200D[\\u2640\\u2642]|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u2600-\\u2604\\u260E\\u2611\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26B0\\u26B1\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0\\u26F1\\u26F4\\u26F7\\u26F8\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]|\\uD83D[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3])\\uFE0F|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB|\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83D\\uDC69(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC08\\u200D\\u2B1B|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79)|\\uD83D\\uDC41\\uFE0F|\\uD83C\\uDFF3\\uFE0F|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\u2764\\uFE0F|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF4|(?:[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270C\\u270D]|\\uD83D[\\uDD74\\uDD90])(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC08\\uDC15\\uDC3B\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE2E\\uDE35\\uDE36\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5]|\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD]|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF]|[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD1D\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78\\uDD7A-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCB\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6]|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDD77\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n            };\n          }\n        });\n        var string_width_exports = {};\n        __export(string_width_exports, {\n          default: () => stringWidth\n        });\n        function stringWidth(string2) {\n          if (typeof string2 !== \"string\" || string2.length === 0) {\n            return 0;\n          }\n          string2 = stripAnsi(string2);\n          if (string2.length === 0) {\n            return 0;\n          }\n          string2 = string2.replace((0, import_emoji_regex.default)(), \"  \");\n          let width = 0;\n          for (let index = 0; index < string2.length; index++) {\n            const codePoint = string2.codePointAt(index);\n            if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {\n              continue;\n            }\n            if (codePoint >= 768 && codePoint <= 879) {\n              continue;\n            }\n            if (codePoint > 65535) {\n              index++;\n            }\n            width += isFullwidthCodePoint(codePoint) ? 2 : 1;\n          }\n          return width;\n        }\n        var import_emoji_regex;\n        var init_string_width = __esm({\n          \"node_modules/string-width/index.js\"() {\n            init_define_process();\n            init_strip_ansi();\n            init_is_fullwidth_code_point();\n            import_emoji_regex = __toESM(require_emoji_regex());\n          }\n        });\n        var require_get_string_width = __commonJS2({\n          \"src/utils/get-string-width.js\"(exports22, module22) {\n            init_define_process();\n            var stringWidth2 = (init_string_width(), __toCommonJS(string_width_exports)).default;\n            var notAsciiRegex = /[^\\x20-\\x7F]/;\n            function getStringWidth(text) {\n              if (!text) {\n                return 0;\n              }\n              if (!notAsciiRegex.test(text)) {\n                return text.length;\n              }\n              return stringWidth2(text);\n            }\n            module22.exports = getStringWidth;\n          }\n        });\n        var require_doc_utils = __commonJS2({\n          \"src/document/doc-utils.js\"(exports22, module22) {\n            init_define_process();\n            var getLast = require_get_last();\n            var {\n              literalline,\n              join\n            } = require_doc_builders();\n            var isConcat = (doc2) => Array.isArray(doc2) || doc2 && doc2.type === \"concat\";\n            var getDocParts = (doc2) => {\n              if (Array.isArray(doc2)) {\n                return doc2;\n              }\n              if (doc2.type !== \"concat\" && doc2.type !== \"fill\") {\n                throw new Error(\"Expect doc type to be `concat` or `fill`.\");\n              }\n              return doc2.parts;\n            };\n            var traverseDocOnExitStackMarker = {};\n            function traverseDoc(doc2, onEnter, onExit, shouldTraverseConditionalGroups) {\n              const docsStack = [doc2];\n              while (docsStack.length > 0) {\n                const doc22 = docsStack.pop();\n                if (doc22 === traverseDocOnExitStackMarker) {\n                  onExit(docsStack.pop());\n                  continue;\n                }\n                if (onExit) {\n                  docsStack.push(doc22, traverseDocOnExitStackMarker);\n                }\n                if (!onEnter || onEnter(doc22) !== false) {\n                  if (isConcat(doc22) || doc22.type === \"fill\") {\n                    const parts = getDocParts(doc22);\n                    for (let ic = parts.length, i = ic - 1; i >= 0; --i) {\n                      docsStack.push(parts[i]);\n                    }\n                  } else if (doc22.type === \"if-break\") {\n                    if (doc22.flatContents) {\n                      docsStack.push(doc22.flatContents);\n                    }\n                    if (doc22.breakContents) {\n                      docsStack.push(doc22.breakContents);\n                    }\n                  } else if (doc22.type === \"group\" && doc22.expandedStates) {\n                    if (shouldTraverseConditionalGroups) {\n                      for (let ic = doc22.expandedStates.length, i = ic - 1; i >= 0; --i) {\n                        docsStack.push(doc22.expandedStates[i]);\n                      }\n                    } else {\n                      docsStack.push(doc22.contents);\n                    }\n                  } else if (doc22.contents) {\n                    docsStack.push(doc22.contents);\n                  }\n                }\n              }\n            }\n            function mapDoc(doc2, cb) {\n              const mapped = /* @__PURE__ */ new Map();\n              return rec(doc2);\n              function rec(doc22) {\n                if (mapped.has(doc22)) {\n                  return mapped.get(doc22);\n                }\n                const result = process2(doc22);\n                mapped.set(doc22, result);\n                return result;\n              }\n              function process2(doc22) {\n                if (Array.isArray(doc22)) {\n                  return cb(doc22.map(rec));\n                }\n                if (doc22.type === \"concat\" || doc22.type === \"fill\") {\n                  const parts = doc22.parts.map(rec);\n                  return cb(Object.assign(Object.assign({}, doc22), {}, {\n                    parts\n                  }));\n                }\n                if (doc22.type === \"if-break\") {\n                  const breakContents = doc22.breakContents && rec(doc22.breakContents);\n                  const flatContents = doc22.flatContents && rec(doc22.flatContents);\n                  return cb(Object.assign(Object.assign({}, doc22), {}, {\n                    breakContents,\n                    flatContents\n                  }));\n                }\n                if (doc22.type === \"group\" && doc22.expandedStates) {\n                  const expandedStates = doc22.expandedStates.map(rec);\n                  const contents = expandedStates[0];\n                  return cb(Object.assign(Object.assign({}, doc22), {}, {\n                    contents,\n                    expandedStates\n                  }));\n                }\n                if (doc22.contents) {\n                  const contents = rec(doc22.contents);\n                  return cb(Object.assign(Object.assign({}, doc22), {}, {\n                    contents\n                  }));\n                }\n                return cb(doc22);\n              }\n            }\n            function findInDoc(doc2, fn, defaultValue) {\n              let result = defaultValue;\n              let hasStopped = false;\n              function findInDocOnEnterFn(doc22) {\n                const maybeResult = fn(doc22);\n                if (maybeResult !== void 0) {\n                  hasStopped = true;\n                  result = maybeResult;\n                }\n                if (hasStopped) {\n                  return false;\n                }\n              }\n              traverseDoc(doc2, findInDocOnEnterFn);\n              return result;\n            }\n            function willBreakFn(doc2) {\n              if (doc2.type === \"group\" && doc2.break) {\n                return true;\n              }\n              if (doc2.type === \"line\" && doc2.hard) {\n                return true;\n              }\n              if (doc2.type === \"break-parent\") {\n                return true;\n              }\n            }\n            function willBreak(doc2) {\n              return findInDoc(doc2, willBreakFn, false);\n            }\n            function breakParentGroup(groupStack) {\n              if (groupStack.length > 0) {\n                const parentGroup = getLast(groupStack);\n                if (!parentGroup.expandedStates && !parentGroup.break) {\n                  parentGroup.break = \"propagated\";\n                }\n              }\n              return null;\n            }\n            function propagateBreaks(doc2) {\n              const alreadyVisitedSet = /* @__PURE__ */ new Set();\n              const groupStack = [];\n              function propagateBreaksOnEnterFn(doc22) {\n                if (doc22.type === \"break-parent\") {\n                  breakParentGroup(groupStack);\n                }\n                if (doc22.type === \"group\") {\n                  groupStack.push(doc22);\n                  if (alreadyVisitedSet.has(doc22)) {\n                    return false;\n                  }\n                  alreadyVisitedSet.add(doc22);\n                }\n              }\n              function propagateBreaksOnExitFn(doc22) {\n                if (doc22.type === \"group\") {\n                  const group2 = groupStack.pop();\n                  if (group2.break) {\n                    breakParentGroup(groupStack);\n                  }\n                }\n              }\n              traverseDoc(doc2, propagateBreaksOnEnterFn, propagateBreaksOnExitFn, true);\n            }\n            function removeLinesFn(doc2) {\n              if (doc2.type === \"line\" && !doc2.hard) {\n                return doc2.soft ? \"\" : \" \";\n              }\n              if (doc2.type === \"if-break\") {\n                return doc2.flatContents || \"\";\n              }\n              return doc2;\n            }\n            function removeLines(doc2) {\n              return mapDoc(doc2, removeLinesFn);\n            }\n            var isHardline = (doc2, nextDoc) => doc2 && doc2.type === \"line\" && doc2.hard && nextDoc && nextDoc.type === \"break-parent\";\n            function stripDocTrailingHardlineFromDoc(doc2) {\n              if (!doc2) {\n                return doc2;\n              }\n              if (isConcat(doc2) || doc2.type === \"fill\") {\n                const parts = getDocParts(doc2);\n                while (parts.length > 1 && isHardline(...parts.slice(-2))) {\n                  parts.length -= 2;\n                }\n                if (parts.length > 0) {\n                  const lastPart = stripDocTrailingHardlineFromDoc(getLast(parts));\n                  parts[parts.length - 1] = lastPart;\n                }\n                return Array.isArray(doc2) ? parts : Object.assign(Object.assign({}, doc2), {}, {\n                  parts\n                });\n              }\n              switch (doc2.type) {\n                case \"align\":\n                case \"indent\":\n                case \"indent-if-break\":\n                case \"group\":\n                case \"line-suffix\":\n                case \"label\": {\n                  const contents = stripDocTrailingHardlineFromDoc(doc2.contents);\n                  return Object.assign(Object.assign({}, doc2), {}, {\n                    contents\n                  });\n                }\n                case \"if-break\": {\n                  const breakContents = stripDocTrailingHardlineFromDoc(doc2.breakContents);\n                  const flatContents = stripDocTrailingHardlineFromDoc(doc2.flatContents);\n                  return Object.assign(Object.assign({}, doc2), {}, {\n                    breakContents,\n                    flatContents\n                  });\n                }\n              }\n              return doc2;\n            }\n            function stripTrailingHardline(doc2) {\n              return stripDocTrailingHardlineFromDoc(cleanDoc(doc2));\n            }\n            function cleanDocFn(doc2) {\n              switch (doc2.type) {\n                case \"fill\":\n                  if (doc2.parts.every((part) => part === \"\")) {\n                    return \"\";\n                  }\n                  break;\n                case \"group\":\n                  if (!doc2.contents && !doc2.id && !doc2.break && !doc2.expandedStates) {\n                    return \"\";\n                  }\n                  if (doc2.contents.type === \"group\" && doc2.contents.id === doc2.id && doc2.contents.break === doc2.break && doc2.contents.expandedStates === doc2.expandedStates) {\n                    return doc2.contents;\n                  }\n                  break;\n                case \"align\":\n                case \"indent\":\n                case \"indent-if-break\":\n                case \"line-suffix\":\n                  if (!doc2.contents) {\n                    return \"\";\n                  }\n                  break;\n                case \"if-break\":\n                  if (!doc2.flatContents && !doc2.breakContents) {\n                    return \"\";\n                  }\n                  break;\n              }\n              if (!isConcat(doc2)) {\n                return doc2;\n              }\n              const parts = [];\n              for (const part of getDocParts(doc2)) {\n                if (!part) {\n                  continue;\n                }\n                const [currentPart, ...restParts] = isConcat(part) ? getDocParts(part) : [part];\n                if (typeof currentPart === \"string\" && typeof getLast(parts) === \"string\") {\n                  parts[parts.length - 1] += currentPart;\n                } else {\n                  parts.push(currentPart);\n                }\n                parts.push(...restParts);\n              }\n              if (parts.length === 0) {\n                return \"\";\n              }\n              if (parts.length === 1) {\n                return parts[0];\n              }\n              return Array.isArray(doc2) ? parts : Object.assign(Object.assign({}, doc2), {}, {\n                parts\n              });\n            }\n            function cleanDoc(doc2) {\n              return mapDoc(doc2, (currentDoc) => cleanDocFn(currentDoc));\n            }\n            function normalizeParts(parts) {\n              const newParts = [];\n              const restParts = parts.filter(Boolean);\n              while (restParts.length > 0) {\n                const part = restParts.shift();\n                if (!part) {\n                  continue;\n                }\n                if (isConcat(part)) {\n                  restParts.unshift(...getDocParts(part));\n                  continue;\n                }\n                if (newParts.length > 0 && typeof getLast(newParts) === \"string\" && typeof part === \"string\") {\n                  newParts[newParts.length - 1] += part;\n                  continue;\n                }\n                newParts.push(part);\n              }\n              return newParts;\n            }\n            function normalizeDoc(doc2) {\n              return mapDoc(doc2, (currentDoc) => {\n                if (Array.isArray(currentDoc)) {\n                  return normalizeParts(currentDoc);\n                }\n                if (!currentDoc.parts) {\n                  return currentDoc;\n                }\n                return Object.assign(Object.assign({}, currentDoc), {}, {\n                  parts: normalizeParts(currentDoc.parts)\n                });\n              });\n            }\n            function replaceEndOfLine(doc2) {\n              return mapDoc(doc2, (currentDoc) => typeof currentDoc === \"string\" && currentDoc.includes(\"\\n\") ? replaceTextEndOfLine(currentDoc) : currentDoc);\n            }\n            function replaceTextEndOfLine(text) {\n              let replacement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : literalline;\n              return join(replacement, text.split(\"\\n\")).parts;\n            }\n            function canBreakFn(doc2) {\n              if (doc2.type === \"line\") {\n                return true;\n              }\n            }\n            function canBreak(doc2) {\n              return findInDoc(doc2, canBreakFn, false);\n            }\n            module22.exports = {\n              isConcat,\n              getDocParts,\n              willBreak,\n              traverseDoc,\n              findInDoc,\n              mapDoc,\n              propagateBreaks,\n              removeLines,\n              stripTrailingHardline,\n              normalizeParts,\n              normalizeDoc,\n              cleanDoc,\n              replaceTextEndOfLine,\n              replaceEndOfLine,\n              canBreak\n            };\n          }\n        });\n        var require_doc_printer = __commonJS2({\n          \"src/document/doc-printer.js\"(exports22, module22) {\n            init_define_process();\n            var {\n              convertEndOfLineToChars\n            } = require_end_of_line();\n            var getLast = require_get_last();\n            var getStringWidth = require_get_string_width();\n            var {\n              fill,\n              cursor,\n              indent\n            } = require_doc_builders();\n            var {\n              isConcat,\n              getDocParts\n            } = require_doc_utils();\n            var groupModeMap;\n            var MODE_BREAK = 1;\n            var MODE_FLAT = 2;\n            function rootIndent() {\n              return {\n                value: \"\",\n                length: 0,\n                queue: []\n              };\n            }\n            function makeIndent(ind, options) {\n              return generateInd(ind, {\n                type: \"indent\"\n              }, options);\n            }\n            function makeAlign(indent2, widthOrDoc, options) {\n              if (widthOrDoc === Number.NEGATIVE_INFINITY) {\n                return indent2.root || rootIndent();\n              }\n              if (widthOrDoc < 0) {\n                return generateInd(indent2, {\n                  type: \"dedent\"\n                }, options);\n              }\n              if (!widthOrDoc) {\n                return indent2;\n              }\n              if (widthOrDoc.type === \"root\") {\n                return Object.assign(Object.assign({}, indent2), {}, {\n                  root: indent2\n                });\n              }\n              const alignType = typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";\n              return generateInd(indent2, {\n                type: alignType,\n                n: widthOrDoc\n              }, options);\n            }\n            function generateInd(ind, newPart, options) {\n              const queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];\n              let value = \"\";\n              let length = 0;\n              let lastTabs = 0;\n              let lastSpaces = 0;\n              for (const part of queue) {\n                switch (part.type) {\n                  case \"indent\":\n                    flush();\n                    if (options.useTabs) {\n                      addTabs(1);\n                    } else {\n                      addSpaces(options.tabWidth);\n                    }\n                    break;\n                  case \"stringAlign\":\n                    flush();\n                    value += part.n;\n                    length += part.n.length;\n                    break;\n                  case \"numberAlign\":\n                    lastTabs += 1;\n                    lastSpaces += part.n;\n                    break;\n                  default:\n                    throw new Error(`Unexpected type '${part.type}'`);\n                }\n              }\n              flushSpaces();\n              return Object.assign(Object.assign({}, ind), {}, {\n                value,\n                length,\n                queue\n              });\n              function addTabs(count) {\n                value += \"\t\".repeat(count);\n                length += options.tabWidth * count;\n              }\n              function addSpaces(count) {\n                value += \" \".repeat(count);\n                length += count;\n              }\n              function flush() {\n                if (options.useTabs) {\n                  flushTabs();\n                } else {\n                  flushSpaces();\n                }\n              }\n              function flushTabs() {\n                if (lastTabs > 0) {\n                  addTabs(lastTabs);\n                }\n                resetLast();\n              }\n              function flushSpaces() {\n                if (lastSpaces > 0) {\n                  addSpaces(lastSpaces);\n                }\n                resetLast();\n              }\n              function resetLast() {\n                lastTabs = 0;\n                lastSpaces = 0;\n              }\n            }\n            function trim(out) {\n              if (out.length === 0) {\n                return 0;\n              }\n              let trimCount = 0;\n              while (out.length > 0 && typeof getLast(out) === \"string\" && /^[\\t ]*$/.test(getLast(out))) {\n                trimCount += out.pop().length;\n              }\n              if (out.length > 0 && typeof getLast(out) === \"string\") {\n                const trimmed = getLast(out).replace(/[\\t ]*$/, \"\");\n                trimCount += getLast(out).length - trimmed.length;\n                out[out.length - 1] = trimmed;\n              }\n              return trimCount;\n            }\n            function fits(next, restCommands, width, hasLineSuffix, mustBeFlat) {\n              let restIdx = restCommands.length;\n              const cmds = [next];\n              const out = [];\n              while (width >= 0) {\n                if (cmds.length === 0) {\n                  if (restIdx === 0) {\n                    return true;\n                  }\n                  cmds.push(restCommands[--restIdx]);\n                  continue;\n                }\n                const {\n                  mode,\n                  doc: doc2\n                } = cmds.pop();\n                if (typeof doc2 === \"string\") {\n                  out.push(doc2);\n                  width -= getStringWidth(doc2);\n                } else if (isConcat(doc2) || doc2.type === \"fill\") {\n                  const parts = getDocParts(doc2);\n                  for (let i = parts.length - 1; i >= 0; i--) {\n                    cmds.push({\n                      mode,\n                      doc: parts[i]\n                    });\n                  }\n                } else {\n                  switch (doc2.type) {\n                    case \"indent\":\n                    case \"align\":\n                    case \"indent-if-break\":\n                    case \"label\":\n                      cmds.push({\n                        mode,\n                        doc: doc2.contents\n                      });\n                      break;\n                    case \"trim\":\n                      width += trim(out);\n                      break;\n                    case \"group\": {\n                      if (mustBeFlat && doc2.break) {\n                        return false;\n                      }\n                      const groupMode = doc2.break ? MODE_BREAK : mode;\n                      const contents = doc2.expandedStates && groupMode === MODE_BREAK ? getLast(doc2.expandedStates) : doc2.contents;\n                      cmds.push({\n                        mode: groupMode,\n                        doc: contents\n                      });\n                      break;\n                    }\n                    case \"if-break\": {\n                      const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] || MODE_FLAT : mode;\n                      const contents = groupMode === MODE_BREAK ? doc2.breakContents : doc2.flatContents;\n                      if (contents) {\n                        cmds.push({\n                          mode,\n                          doc: contents\n                        });\n                      }\n                      break;\n                    }\n                    case \"line\":\n                      if (mode === MODE_BREAK || doc2.hard) {\n                        return true;\n                      }\n                      if (!doc2.soft) {\n                        out.push(\" \");\n                        width--;\n                      }\n                      break;\n                    case \"line-suffix\":\n                      hasLineSuffix = true;\n                      break;\n                    case \"line-suffix-boundary\":\n                      if (hasLineSuffix) {\n                        return false;\n                      }\n                      break;\n                  }\n                }\n              }\n              return false;\n            }\n            function printDocToString(doc2, options) {\n              groupModeMap = {};\n              const width = options.printWidth;\n              const newLine = convertEndOfLineToChars(options.endOfLine);\n              let pos = 0;\n              const cmds = [{\n                ind: rootIndent(),\n                mode: MODE_BREAK,\n                doc: doc2\n              }];\n              const out = [];\n              let shouldRemeasure = false;\n              const lineSuffix = [];\n              while (cmds.length > 0) {\n                const {\n                  ind,\n                  mode,\n                  doc: doc22\n                } = cmds.pop();\n                if (typeof doc22 === \"string\") {\n                  const formatted = newLine !== \"\\n\" ? doc22.replace(/\\n/g, newLine) : doc22;\n                  out.push(formatted);\n                  pos += getStringWidth(formatted);\n                } else if (isConcat(doc22)) {\n                  const parts = getDocParts(doc22);\n                  for (let i = parts.length - 1; i >= 0; i--) {\n                    cmds.push({\n                      ind,\n                      mode,\n                      doc: parts[i]\n                    });\n                  }\n                } else {\n                  switch (doc22.type) {\n                    case \"cursor\":\n                      out.push(cursor.placeholder);\n                      break;\n                    case \"indent\":\n                      cmds.push({\n                        ind: makeIndent(ind, options),\n                        mode,\n                        doc: doc22.contents\n                      });\n                      break;\n                    case \"align\":\n                      cmds.push({\n                        ind: makeAlign(ind, doc22.n, options),\n                        mode,\n                        doc: doc22.contents\n                      });\n                      break;\n                    case \"trim\":\n                      pos -= trim(out);\n                      break;\n                    case \"group\":\n                      switch (mode) {\n                        case MODE_FLAT:\n                          if (!shouldRemeasure) {\n                            cmds.push({\n                              ind,\n                              mode: doc22.break ? MODE_BREAK : MODE_FLAT,\n                              doc: doc22.contents\n                            });\n                            break;\n                          }\n                        case MODE_BREAK: {\n                          shouldRemeasure = false;\n                          const next = {\n                            ind,\n                            mode: MODE_FLAT,\n                            doc: doc22.contents\n                          };\n                          const rem = width - pos;\n                          const hasLineSuffix = lineSuffix.length > 0;\n                          if (!doc22.break && fits(next, cmds, rem, hasLineSuffix)) {\n                            cmds.push(next);\n                          } else {\n                            if (doc22.expandedStates) {\n                              const mostExpanded = getLast(doc22.expandedStates);\n                              if (doc22.break) {\n                                cmds.push({\n                                  ind,\n                                  mode: MODE_BREAK,\n                                  doc: mostExpanded\n                                });\n                                break;\n                              } else {\n                                for (let i = 1; i < doc22.expandedStates.length + 1; i++) {\n                                  if (i >= doc22.expandedStates.length) {\n                                    cmds.push({\n                                      ind,\n                                      mode: MODE_BREAK,\n                                      doc: mostExpanded\n                                    });\n                                    break;\n                                  } else {\n                                    const state = doc22.expandedStates[i];\n                                    const cmd = {\n                                      ind,\n                                      mode: MODE_FLAT,\n                                      doc: state\n                                    };\n                                    if (fits(cmd, cmds, rem, hasLineSuffix)) {\n                                      cmds.push(cmd);\n                                      break;\n                                    }\n                                  }\n                                }\n                              }\n                            } else {\n                              cmds.push({\n                                ind,\n                                mode: MODE_BREAK,\n                                doc: doc22.contents\n                              });\n                            }\n                          }\n                          break;\n                        }\n                      }\n                      if (doc22.id) {\n                        groupModeMap[doc22.id] = getLast(cmds).mode;\n                      }\n                      break;\n                    case \"fill\": {\n                      const rem = width - pos;\n                      const {\n                        parts\n                      } = doc22;\n                      if (parts.length === 0) {\n                        break;\n                      }\n                      const [content, whitespace2] = parts;\n                      const contentFlatCmd = {\n                        ind,\n                        mode: MODE_FLAT,\n                        doc: content\n                      };\n                      const contentBreakCmd = {\n                        ind,\n                        mode: MODE_BREAK,\n                        doc: content\n                      };\n                      const contentFits = fits(contentFlatCmd, [], rem, lineSuffix.length > 0, true);\n                      if (parts.length === 1) {\n                        if (contentFits) {\n                          cmds.push(contentFlatCmd);\n                        } else {\n                          cmds.push(contentBreakCmd);\n                        }\n                        break;\n                      }\n                      const whitespaceFlatCmd = {\n                        ind,\n                        mode: MODE_FLAT,\n                        doc: whitespace2\n                      };\n                      const whitespaceBreakCmd = {\n                        ind,\n                        mode: MODE_BREAK,\n                        doc: whitespace2\n                      };\n                      if (parts.length === 2) {\n                        if (contentFits) {\n                          cmds.push(whitespaceFlatCmd, contentFlatCmd);\n                        } else {\n                          cmds.push(whitespaceBreakCmd, contentBreakCmd);\n                        }\n                        break;\n                      }\n                      parts.splice(0, 2);\n                      const remainingCmd = {\n                        ind,\n                        mode,\n                        doc: fill(parts)\n                      };\n                      const secondContent = parts[0];\n                      const firstAndSecondContentFlatCmd = {\n                        ind,\n                        mode: MODE_FLAT,\n                        doc: [content, whitespace2, secondContent]\n                      };\n                      const firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], rem, lineSuffix.length > 0, true);\n                      if (firstAndSecondContentFits) {\n                        cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);\n                      } else if (contentFits) {\n                        cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);\n                      } else {\n                        cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);\n                      }\n                      break;\n                    }\n                    case \"if-break\":\n                    case \"indent-if-break\": {\n                      const groupMode = doc22.groupId ? groupModeMap[doc22.groupId] : mode;\n                      if (groupMode === MODE_BREAK) {\n                        const breakContents = doc22.type === \"if-break\" ? doc22.breakContents : doc22.negate ? doc22.contents : indent(doc22.contents);\n                        if (breakContents) {\n                          cmds.push({\n                            ind,\n                            mode,\n                            doc: breakContents\n                          });\n                        }\n                      }\n                      if (groupMode === MODE_FLAT) {\n                        const flatContents = doc22.type === \"if-break\" ? doc22.flatContents : doc22.negate ? indent(doc22.contents) : doc22.contents;\n                        if (flatContents) {\n                          cmds.push({\n                            ind,\n                            mode,\n                            doc: flatContents\n                          });\n                        }\n                      }\n                      break;\n                    }\n                    case \"line-suffix\":\n                      lineSuffix.push({\n                        ind,\n                        mode,\n                        doc: doc22.contents\n                      });\n                      break;\n                    case \"line-suffix-boundary\":\n                      if (lineSuffix.length > 0) {\n                        cmds.push({\n                          ind,\n                          mode,\n                          doc: {\n                            type: \"line\",\n                            hard: true\n                          }\n                        });\n                      }\n                      break;\n                    case \"line\":\n                      switch (mode) {\n                        case MODE_FLAT:\n                          if (!doc22.hard) {\n                            if (!doc22.soft) {\n                              out.push(\" \");\n                              pos += 1;\n                            }\n                            break;\n                          } else {\n                            shouldRemeasure = true;\n                          }\n                        case MODE_BREAK:\n                          if (lineSuffix.length > 0) {\n                            cmds.push({\n                              ind,\n                              mode,\n                              doc: doc22\n                            }, ...lineSuffix.reverse());\n                            lineSuffix.length = 0;\n                            break;\n                          }\n                          if (doc22.literal) {\n                            if (ind.root) {\n                              out.push(newLine, ind.root.value);\n                              pos = ind.root.length;\n                            } else {\n                              out.push(newLine);\n                              pos = 0;\n                            }\n                          } else {\n                            pos -= trim(out);\n                            out.push(newLine + ind.value);\n                            pos = ind.length;\n                          }\n                          break;\n                      }\n                      break;\n                    case \"label\":\n                      cmds.push({\n                        ind,\n                        mode,\n                        doc: doc22.contents\n                      });\n                      break;\n                  }\n                }\n                if (cmds.length === 0 && lineSuffix.length > 0) {\n                  cmds.push(...lineSuffix.reverse());\n                  lineSuffix.length = 0;\n                }\n              }\n              const cursorPlaceholderIndex = out.indexOf(cursor.placeholder);\n              if (cursorPlaceholderIndex !== -1) {\n                const otherCursorPlaceholderIndex = out.indexOf(cursor.placeholder, cursorPlaceholderIndex + 1);\n                const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n                const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n                const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n                return {\n                  formatted: beforeCursor + aroundCursor + afterCursor,\n                  cursorNodeStart: beforeCursor.length,\n                  cursorNodeText: aroundCursor\n                };\n              }\n              return {\n                formatted: out.join(\"\")\n              };\n            }\n            module22.exports = {\n              printDocToString\n            };\n          }\n        });\n        var require_doc_debug = __commonJS2({\n          \"src/document/doc-debug.js\"(exports22, module22) {\n            init_define_process();\n            var {\n              isConcat,\n              getDocParts\n            } = require_doc_utils();\n            function flattenDoc(doc2) {\n              if (!doc2) {\n                return \"\";\n              }\n              if (isConcat(doc2)) {\n                const res = [];\n                for (const part of getDocParts(doc2)) {\n                  if (isConcat(part)) {\n                    res.push(...flattenDoc(part).parts);\n                  } else {\n                    const flattened = flattenDoc(part);\n                    if (flattened !== \"\") {\n                      res.push(flattened);\n                    }\n                  }\n                }\n                return {\n                  type: \"concat\",\n                  parts: res\n                };\n              }\n              if (doc2.type === \"if-break\") {\n                return Object.assign(Object.assign({}, doc2), {}, {\n                  breakContents: flattenDoc(doc2.breakContents),\n                  flatContents: flattenDoc(doc2.flatContents)\n                });\n              }\n              if (doc2.type === \"group\") {\n                return Object.assign(Object.assign({}, doc2), {}, {\n                  contents: flattenDoc(doc2.contents),\n                  expandedStates: doc2.expandedStates && doc2.expandedStates.map(flattenDoc)\n                });\n              }\n              if (doc2.type === \"fill\") {\n                return {\n                  type: \"fill\",\n                  parts: doc2.parts.map(flattenDoc)\n                };\n              }\n              if (doc2.contents) {\n                return Object.assign(Object.assign({}, doc2), {}, {\n                  contents: flattenDoc(doc2.contents)\n                });\n              }\n              return doc2;\n            }\n            function printDocToDebug(doc2) {\n              const printedSymbols = /* @__PURE__ */ Object.create(null);\n              const usedKeysForSymbols = /* @__PURE__ */ new Set();\n              return printDoc(flattenDoc(doc2));\n              function printDoc(doc22, index, parentParts) {\n                if (typeof doc22 === \"string\") {\n                  return JSON.stringify(doc22);\n                }\n                if (isConcat(doc22)) {\n                  const printed = getDocParts(doc22).map(printDoc).filter(Boolean);\n                  return printed.length === 1 ? printed[0] : `[${printed.join(\", \")}]`;\n                }\n                if (doc22.type === \"line\") {\n                  const withBreakParent = Array.isArray(parentParts) && parentParts[index + 1] && parentParts[index + 1].type === \"break-parent\";\n                  if (doc22.literal) {\n                    return withBreakParent ? \"literalline\" : \"literallineWithoutBreakParent\";\n                  }\n                  if (doc22.hard) {\n                    return withBreakParent ? \"hardline\" : \"hardlineWithoutBreakParent\";\n                  }\n                  if (doc22.soft) {\n                    return \"softline\";\n                  }\n                  return \"line\";\n                }\n                if (doc22.type === \"break-parent\") {\n                  const afterHardline = Array.isArray(parentParts) && parentParts[index - 1] && parentParts[index - 1].type === \"line\" && parentParts[index - 1].hard;\n                  return afterHardline ? void 0 : \"breakParent\";\n                }\n                if (doc22.type === \"trim\") {\n                  return \"trim\";\n                }\n                if (doc22.type === \"indent\") {\n                  return \"indent(\" + printDoc(doc22.contents) + \")\";\n                }\n                if (doc22.type === \"align\") {\n                  return doc22.n === Number.NEGATIVE_INFINITY ? \"dedentToRoot(\" + printDoc(doc22.contents) + \")\" : doc22.n < 0 ? \"dedent(\" + printDoc(doc22.contents) + \")\" : doc22.n.type === \"root\" ? \"markAsRoot(\" + printDoc(doc22.contents) + \")\" : \"align(\" + JSON.stringify(doc22.n) + \", \" + printDoc(doc22.contents) + \")\";\n                }\n                if (doc22.type === \"if-break\") {\n                  return \"ifBreak(\" + printDoc(doc22.breakContents) + (doc22.flatContents ? \", \" + printDoc(doc22.flatContents) : \"\") + (doc22.groupId ? (!doc22.flatContents ? ', \"\"' : \"\") + `, { groupId: ${printGroupId(doc22.groupId)} }` : \"\") + \")\";\n                }\n                if (doc22.type === \"indent-if-break\") {\n                  const optionsParts = [];\n                  if (doc22.negate) {\n                    optionsParts.push(\"negate: true\");\n                  }\n                  if (doc22.groupId) {\n                    optionsParts.push(`groupId: ${printGroupId(doc22.groupId)}`);\n                  }\n                  const options = optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";\n                  return `indentIfBreak(${printDoc(doc22.contents)}${options})`;\n                }\n                if (doc22.type === \"group\") {\n                  const optionsParts = [];\n                  if (doc22.break && doc22.break !== \"propagated\") {\n                    optionsParts.push(\"shouldBreak: true\");\n                  }\n                  if (doc22.id) {\n                    optionsParts.push(`id: ${printGroupId(doc22.id)}`);\n                  }\n                  const options = optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";\n                  if (doc22.expandedStates) {\n                    return `conditionalGroup([${doc22.expandedStates.map((part) => printDoc(part)).join(\",\")}]${options})`;\n                  }\n                  return `group(${printDoc(doc22.contents)}${options})`;\n                }\n                if (doc22.type === \"fill\") {\n                  return `fill([${doc22.parts.map((part) => printDoc(part)).join(\", \")}])`;\n                }\n                if (doc22.type === \"line-suffix\") {\n                  return \"lineSuffix(\" + printDoc(doc22.contents) + \")\";\n                }\n                if (doc22.type === \"line-suffix-boundary\") {\n                  return \"lineSuffixBoundary\";\n                }\n                if (doc22.type === \"label\") {\n                  return `label(${JSON.stringify(doc22.label)}, ${printDoc(doc22.contents)})`;\n                }\n                throw new Error(\"Unknown doc type \" + doc22.type);\n              }\n              function printGroupId(id) {\n                if (typeof id !== \"symbol\") {\n                  return JSON.stringify(String(id));\n                }\n                if (id in printedSymbols) {\n                  return printedSymbols[id];\n                }\n                const prefix = String(id).slice(7, -1) || \"symbol\";\n                for (let counter = 0; ; counter++) {\n                  const key = prefix + (counter > 0 ? ` #${counter}` : \"\");\n                  if (!usedKeysForSymbols.has(key)) {\n                    usedKeysForSymbols.add(key);\n                    return printedSymbols[id] = `Symbol.for(${JSON.stringify(key)})`;\n                  }\n                }\n              }\n            }\n            module22.exports = {\n              printDocToDebug\n            };\n          }\n        });\n        init_define_process();\n        module2.exports = {\n          builders: require_doc_builders(),\n          printer: require_doc_printer(),\n          utils: require_doc_utils(),\n          debug: require_doc_debug()\n        };\n      }\n    });\n    return require_doc_js_umd();\n  });\n})(doc);\nconst MAX_LINES = 4;\nconst defaultOptions = {\n  printWidth: 30,\n  tabWidth: 4,\n  useTabs: false\n};\nfunction prettierPrint(doc2) {\n  return docExports.printer.printDocToString(doc2, defaultOptions).formatted;\n}\nfunction addCursor(state, cursor = \"^\", error = false) {\n  const color = (error ? chalk.red : chalk.green).bold;\n  const lines = state.src.split(\"\\n\");\n  const lineIdx = Math.min(lines.length - 1, state.getLineNumber());\n  const startIdx = Math.max(lineIdx - MAX_LINES, 0);\n  const endIdx = Math.min(lineIdx + MAX_LINES + 1, lines.length);\n  const lineSummaries = lines.slice(startIdx, endIdx);\n  if (cursor) {\n    const cursorLine = \" \".repeat(state.getColumnNumber()) + color(cursor);\n    lineSummaries.splice(lineIdx - startIdx + 1, 0, cursorLine);\n  }\n  const resultLines = lineSummaries.map((line, idx) => {\n    const lineNum = startIdx + idx + 1;\n    let paddedLineNum = color.reset.black(String(lineNum));\n    line = lineNum === lineIdx + 1 ? color(line) : line;\n    const paddedLine = `      ${paddedLineNum}| ${line}`;\n    return paddedLine;\n  });\n  return resultLines.join(\"\\n\");\n}\nconst group = (docs, groupOptions = {}) => {\n  return docExports.builders.group(docs, { ...defaultOptions, ...groupOptions });\n};\nconst opStyle = (op) => chalk.gray(op);\nconst PARSER_STRINGS = /* @__PURE__ */ new Map();\nfunction parserPrint(parser) {\n  if (PARSER_STRINGS.has(parser.id)) {\n    return PARSER_STRINGS.get(parser.id);\n  }\n  const print = (innerParser, id) => {\n    if (PARSER_STRINGS.has(innerParser.id)) {\n      return PARSER_STRINGS.get(innerParser.id);\n    }\n    const { name, args, parser: innerInnerParser } = innerParser.context;\n    const parserString = innerInnerParser != null ? print(innerInnerParser, id) : chalk.red.bold(\"unknown\");\n    let s2 = (() => {\n      switch (name) {\n        case \"string\":\n          return chalk.yellow(`\"${args[0]}\"`);\n        case \"regex\":\n        case \"regexConcat\":\n        case \"regexWrap\":\n          return chalk.redBright(`${args[0]}`);\n        case \"wrap\":\n        case \"trim\": {\n          const [left, right] = args;\n          return group([\n            print(left, id),\n            docExports.builders.indent([docExports.builders.softline, parserString]),\n            docExports.builders.softline,\n            print(right, id)\n          ]);\n        }\n        case \"trimWhitespace\":\n          return group([parserString, opStyle(\"?w\")]);\n        case \"not\":\n          return group([\"!\", parserString]);\n        case \"opt\":\n          return group([parserString, opStyle(\"?\")]);\n        case \"next\":\n          const [next] = args;\n          return group([parserString, opStyle(\" >> \"), print(next, id)]);\n        case \"skip\":\n          const [skip] = args;\n          return group([parserString, opStyle(\" << \"), print(skip, id)]);\n        case \"map\":\n          return parserString;\n        case \"all\":\n        case \"then\": {\n          const delim = opStyle(\", \");\n          return group([\n            \"[\",\n            docExports.builders.indent([\n              docExports.builders.softline,\n              docExports.builders.join(\n                [delim, docExports.builders.softline],\n                args.map((x) => print(x, id))\n              )\n            ]),\n            docExports.builders.softline,\n            \"]\"\n          ]);\n        }\n        case \"any\":\n        case \"or\": {\n          const delim = opStyle(\"| \");\n          return group([\n            [\n              docExports.builders.join(\n                [docExports.builders.softline, docExports.builders.ifBreak(delim, \" \" + delim)],\n                args.map((x) => print(x, id))\n              )\n            ]\n          ]);\n        }\n        case \"many\":\n          const [min, max] = args;\n          let bounds = max === Infinity ? `${min},` : `${min},${max}`;\n          bounds = chalk.bold.gray(` {${bounds}}`);\n          return group([parserString, bounds]);\n        case \"sepBy\":\n          return group([\n            parserString,\n            docExports.builders.indent([\" sepBy \", print(args[0], id)])\n          ]);\n        case \"lazy\": {\n          const [lazy2] = args;\n          const p = getLazyParser(lazy2);\n          if (!id) {\n            const s3 = print(p, p.id);\n            PARSER_STRINGS.set(p.id, s3);\n            return s3;\n          } else {\n            return chalk.bold.blue(name);\n          }\n        }\n        case \"debug\":\n          return parserString;\n      }\n    })();\n    s2 ?? (s2 = chalk.red.bold(name));\n    if (id) {\n      PARSER_STRINGS.set(innerParser.id, s2);\n    }\n    return s2;\n  };\n  const doc2 = print(parser);\n  const s = prettierPrint(doc2);\n  PARSER_STRINGS.set(parser.id, s);\n  return s;\n}\nfunction statePrint(state, name = \"\", parserString = \"\") {\n  const stateBgColor = !state.isError ? chalk.bgGreen : chalk.bgRed;\n  const stateColor = !state.isError ? chalk.green : chalk.red;\n  const finished = state.offset >= state.src.length;\n  const stateSymbol = !state.isError ? finished ? \"\" : \"\" : \"\";\n  const stateName = !state.isError ? finished ? \"Done\" : \"Ok\" : \"Err\";\n  const stateString = \" \" + stateName + \" \" + stateSymbol + \" \";\n  const header = group([\n    stateBgColor.bold(stateString),\n    stateColor(`\t${name}\t${state.offset}`),\n    docExports.builders.softline,\n    \"\t\" + chalk.yellow(parserString)\n  ]);\n  const body = (() => {\n    if (state.offset >= state.src.length) {\n      return chalk.bold.greenBright(addCursor(state, \"\", state.isError));\n    }\n    return addCursor(state, \"^\", state.isError);\n  })();\n  const headerBody = group([header, docExports.builders.hardline, docExports.builders.indent([body])]);\n  return prettierPrint(headerBody);\n}\nfunction parserDebug(parser, name = \"\", recursivePrint = false, logger = console.log) {\n  const debug = (state) => {\n    const newState = parser.parser(state);\n    const parserString = recursivePrint ? parserPrint(parser) : parser.context.name;\n    const s = statePrint(newState, name, parserString);\n    logger(s);\n    return newState;\n  };\n  return new Parser(debug, createParserContext(\"debug\", parser, logger));\n}\nclass ParserState {\n  constructor(src, value = void 0, offset = 0, isError = false, furthest = 0) {\n    this.src = src;\n    this.value = value;\n    this.offset = offset;\n    this.isError = isError;\n    this.furthest = furthest;\n  }\n  ok(value, offset = 0) {\n    offset += this.offset;\n    return new ParserState(this.src, value, offset, false);\n  }\n  err(value, offset = 0) {\n    const nextState = this.ok(value, offset);\n    nextState.isError = true;\n    return nextState;\n  }\n  from(value, offset = 0) {\n    offset += this.offset;\n    return new ParserState(this.src, value, offset, this.isError);\n  }\n  getColumnNumber() {\n    const offset = this.offset;\n    const lastNewline = this.src.lastIndexOf(\"\\n\", offset);\n    const columnNumber = lastNewline === -1 ? offset : offset - (lastNewline + 1);\n    return Math.max(0, columnNumber);\n  }\n  getLineNumber() {\n    const newlineIndex = this.src.lastIndexOf(\"\\n\", this.offset);\n    return newlineIndex >= 0 ? this.src.slice(0, newlineIndex).split(\"\\n\").length : 0;\n  }\n  toString() {\n    return statePrint(this);\n  }\n}\nfunction createParserContext(name, parser, ...args) {\n  return {\n    name,\n    parser,\n    args\n  };\n}\nlet PARSER_ID = 0;\nconst MEMO = /* @__PURE__ */ new Map();\nconst LEFT_RECURSION_COUNTS = /* @__PURE__ */ new Map();\nlet lastState;\nfunction mergeErrorState(state) {\n  if (!lastState || lastState && state.offset > lastState.offset) {\n    lastState = state;\n  }\n  return lastState;\n}\nfunction getLazyParser(fn) {\n  if (fn.parser) {\n    return fn.parser;\n  }\n  return fn.parser = fn();\n}\nclass Parser {\n  constructor(parser, context = {}) {\n    __publicField(this, \"id\", PARSER_ID++);\n    __publicField(this, \"state\");\n    this.parser = parser;\n    this.context = context;\n  }\n  reset() {\n    lastState = void 0;\n    MEMO.clear();\n    LEFT_RECURSION_COUNTS.clear();\n  }\n  parse(val) {\n    this.reset();\n    const newState = this.parser(new ParserState(val));\n    this.state = mergeErrorState(newState);\n    this.state.isError = newState.isError;\n    return newState.value;\n  }\n  getCijKey(state) {\n    return `${this.id}${state.offset}`;\n  }\n  atLeftRecursionLimit(state) {\n    const cij = LEFT_RECURSION_COUNTS.get(this.getCijKey(state)) ?? 0;\n    return cij > state.src.length - state.offset;\n  }\n  memoize() {\n    const memoize = (state) => {\n      const cijKey = this.getCijKey(state);\n      const cij = LEFT_RECURSION_COUNTS.get(cijKey) ?? 0;\n      let cached = MEMO.get(this.id);\n      if (cached && cached.offset >= state.offset) {\n        return cached;\n      } else if (this.atLeftRecursionLimit(state)) {\n        return state.err(void 0);\n      }\n      LEFT_RECURSION_COUNTS.set(cijKey, cij + 1);\n      const newState = this.parser(state);\n      cached = MEMO.get(this.id);\n      if (cached && cached.offset > newState.offset) {\n        newState.offset = cached.offset;\n      } else if (!cached) {\n        MEMO.set(this.id, newState);\n      }\n      return newState;\n    };\n    return new Parser(\n      memoize,\n      createParserContext(\"memoize\", this)\n    );\n  }\n  mergeMemos() {\n    const mergeMemo = (state) => {\n      let cached = MEMO.get(this.id);\n      if (cached) {\n        return cached;\n      } else if (this.atLeftRecursionLimit(state)) {\n        return state.err(void 0);\n      }\n      const newState = this.parser(state);\n      cached = MEMO.get(this.id);\n      if (!cached) {\n        MEMO.set(this.id, newState);\n      }\n      return newState;\n    };\n    return new Parser(\n      mergeMemo,\n      createParserContext(\"mergeMemo\", this)\n    );\n  }\n  then(next) {\n    if (isStringParsers(this, next)) {\n      return concatStringParsers([this, next], \"\", (m) => [m == null ? void 0 : m[0], m == null ? void 0 : m[1]]);\n    }\n    const then = (state) => {\n      const nextState1 = this.parser(state);\n      if (!nextState1.isError) {\n        const nextState2 = next.parser(nextState1);\n        if (!nextState2.isError) {\n          return nextState2.ok([nextState1.value, nextState2.value]);\n        }\n      }\n      mergeErrorState(state);\n      return state.err(void 0);\n    };\n    return new Parser(\n      then,\n      createParserContext(\"then\", this, this, next)\n    );\n  }\n  or(other) {\n    if (isStringParsers(this, other)) {\n      return concatStringParsers([this, other], \"|\");\n    }\n    const or = (state) => {\n      const newState = this.parser(state);\n      if (!newState.isError) {\n        return newState;\n      }\n      return other.parser(state);\n    };\n    return new Parser(\n      or,\n      createParserContext(\"or\", this, this, other)\n    );\n  }\n  chain(fn, chainError = false) {\n    const chain = (state) => {\n      const newState = this.parser(state);\n      if (newState.isError) {\n        return newState;\n      } else if (newState.value || chainError) {\n        return fn(newState.value).parser(newState);\n      }\n      return state;\n    };\n    return new Parser(chain, createParserContext(\"chain\", this, fn));\n  }\n  map(fn, mapError = false) {\n    const map = (state) => {\n      const newState = this.parser(state);\n      if (!newState.isError || mapError) {\n        return newState.ok(fn(newState.value));\n      }\n      return newState;\n    };\n    return new Parser(map, createParserContext(\"map\", this));\n  }\n  mapState(fn) {\n    const mapState = (state) => {\n      const newState = this.parser(state);\n      return fn(newState);\n    };\n    return new Parser(\n      mapState,\n      createParserContext(\"mapState\", this)\n    );\n  }\n  skip(parser) {\n    const skip = (state) => {\n      const nextState1 = this.parser(state);\n      if (!nextState1.isError) {\n        const nextState2 = parser.parser(nextState1);\n        if (!nextState2.isError) {\n          return nextState2.ok(nextState1.value);\n        }\n      }\n      mergeErrorState(state);\n      return state.err(void 0);\n    };\n    return new Parser(\n      skip,\n      createParserContext(\"skip\", this, parser)\n    );\n  }\n  next(parser) {\n    const next = this.then(parser).map(([, b]) => {\n      return b;\n    });\n    next.context = createParserContext(\"next\", this, parser);\n    return next;\n  }\n  opt() {\n    const opt = (state) => {\n      const newState = this.parser(state);\n      if (newState.isError) {\n        mergeErrorState(state);\n        return state.ok(void 0);\n      }\n      return newState;\n    };\n    return new Parser(opt, createParserContext(\"opt\", this));\n  }\n  not(parser) {\n    const negate = (state) => {\n      const newState = this.parser(state);\n      if (newState.isError) {\n        mergeErrorState(state);\n        return state.ok(state.value);\n      } else {\n        return state.err(void 0);\n      }\n    };\n    const not = (state) => {\n      const newState = this.parser(state);\n      if (newState.isError) {\n        mergeErrorState(state);\n        return newState;\n      } else {\n        const nextState = parser.parser(state);\n        if (nextState.isError) {\n          return newState;\n        } else {\n          mergeErrorState(state);\n          return state.err(void 0);\n        }\n      }\n    };\n    return new Parser(\n      parser ? not : negate,\n      createParserContext(\"not\", this, parser)\n    );\n  }\n  wrap(start, end, discard = true) {\n    if (!discard) {\n      return all(start, this, end);\n    }\n    if (isStringParsers(start, this, end)) {\n      return wrapStringParsers(start, this, end);\n    }\n    const wrap = start.next(this).skip(end);\n    wrap.context = createParserContext(\"wrap\", this, start, end);\n    return wrap;\n  }\n  trim(parser = whitespace, discard = true) {\n    var _a;\n    if (!discard) {\n      return all(parser, this, parser);\n    }\n    if (((_a = parser.context) == null ? void 0 : _a.name) === \"whitespace\") {\n      if (isStringParsers(this, parser)) {\n        return concatStringParsers(\n          [parser, this, parser],\n          \"\",\n          (m) => m == null ? void 0 : m[2]\n        );\n      }\n      const whitespaceTrim = (state) => {\n        const newState = trimStateWhitespace(state);\n        const tmpState = this.parser(newState);\n        if (tmpState.isError) {\n          mergeErrorState(state);\n          return state.err(void 0);\n        } else {\n          return trimStateWhitespace(tmpState);\n        }\n      };\n      return new Parser(\n        whitespaceTrim,\n        createParserContext(\"trimWhitespace\", this)\n      );\n    }\n    return this.wrap(parser, parser);\n  }\n  many(min = 0, max = Infinity) {\n    const many = (state) => {\n      const matches = [];\n      let newState = state;\n      for (let i = 0; i < max; i += 1) {\n        const tmpState = this.parser(newState);\n        if (tmpState.isError) {\n          break;\n        }\n        matches.push(tmpState.value);\n        newState = tmpState;\n      }\n      if (matches.length >= min) {\n        return newState.ok(matches);\n      }\n      mergeErrorState(state);\n      return state.err([]);\n    };\n    return new Parser(\n      many,\n      createParserContext(\"many\", this, min, max)\n    );\n  }\n  sepBy(sep, min = 0, max = Infinity) {\n    const sepBy = (state) => {\n      const matches = [];\n      let newState = state;\n      for (let i = 0; i < max; i += 1) {\n        const tmpState = this.parser(newState);\n        if (tmpState.isError) {\n          break;\n        }\n        newState = tmpState;\n        matches.push(newState.value);\n        const sepState = sep.parser(newState);\n        if (sepState.isError) {\n          break;\n        }\n        newState = sepState;\n      }\n      if (matches.length > min) {\n        return newState.ok(matches);\n      }\n      mergeErrorState(state);\n      return state.err([]);\n    };\n    return new Parser(\n      sepBy,\n      createParserContext(\"sepBy\", this, sep)\n    );\n  }\n  eof() {\n    const p = this.skip(eof());\n    p.context = createParserContext(\"eof\", this);\n    return p;\n  }\n  debug(name = \"\", recursivePrint = false, logger = console.log) {\n    return parserDebug(this, name, recursivePrint, logger);\n  }\n  toString() {\n    return parserPrint(this);\n  }\n  static lazy(fn) {\n    const lazy2 = (state) => {\n      return getLazyParser(fn).parser(state);\n    };\n    return new Parser(lazy2, createParserContext(\"lazy\", void 0, fn));\n  }\n}\nfunction isStringParsers(...parsers) {\n  return parsers.every(\n    (p) => {\n      var _a, _b, _c, _d;\n      return (((_a = p.context) == null ? void 0 : _a.name) === \"string\" || ((_b = p.context) == null ? void 0 : _b.name) === \"regex\" || ((_c = p.context) == null ? void 0 : _c.name) === \"whitespace\") && ((_d = p.context) == null ? void 0 : _d.args);\n    }\n  );\n}\nfunction stringParserValue(p) {\n  var _a, _b, _c, _d, _e;\n  if (((_a = p.context) == null ? void 0 : _a.name) === \"string\") {\n    return (_b = p.context) == null ? void 0 : _b.args[0].replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n  } else if (((_c = p.context) == null ? void 0 : _c.name) === \"regex\" || ((_d = p.context) == null ? void 0 : _d.name) === \"whitespace\") {\n    return (_e = p.context) == null ? void 0 : _e.args[0].source;\n  }\n}\nfunction concatStringParsers(parsers, delim = \"\", matchFunction) {\n  const s = parsers.map((s2) => `(${stringParserValue(s2)})`).join(delim);\n  const r = new RegExp(s);\n  const rP = regex(r, matchFunction);\n  if (delim !== \"|\") {\n    rP.context = createParserContext(\"regexConcat\", this, r);\n  }\n  return rP;\n}\nfunction wrapStringParsers(left, p, right) {\n  const rP = concatStringParsers([left, p, right], \"\", (m) => {\n    return m == null ? void 0 : m[2];\n  });\n  rP.context.name = \"regexWrap\";\n  return rP;\n}\nfunction eof() {\n  const eof2 = (state) => {\n    if (state.offset >= state.src.length) {\n      return state.ok(void 0);\n    } else {\n      mergeErrorState(state);\n      return state.err();\n    }\n  };\n  return new Parser(eof2, createParserContext(\"eof\", void 0));\n}\nfunction lazy(target, propertyName, descriptor) {\n  const method = descriptor.value.bind(target);\n  descriptor.value = function() {\n    const lazy2 = (state) => {\n      return getLazyParser(method).parser(state);\n    };\n    return new Parser(lazy2, createParserContext(\"lazy\", void 0, method));\n  };\n}\nfunction any(...parsers) {\n  if (isStringParsers(...parsers)) {\n    return concatStringParsers(parsers, \"|\");\n  }\n  const any2 = (state) => {\n    for (const parser of parsers) {\n      const newState = parser.parser(state);\n      if (!newState.isError) {\n        return newState;\n      }\n    }\n    mergeErrorState(state);\n    return state.err(void 0);\n  };\n  return new Parser(\n    parsers.length === 1 ? parsers[0].parser : any2,\n    createParserContext(\"any\", void 0, ...parsers)\n  );\n}\nfunction all(...parsers) {\n  const all2 = (state) => {\n    const matches = [];\n    for (const parser of parsers) {\n      const newState = parser.parser(state);\n      if (newState.isError) {\n        return newState;\n      }\n      if (newState.value !== void 0) {\n        matches.push(newState.value);\n      }\n      state = newState;\n    }\n    mergeErrorState(state);\n    return state.ok(matches);\n  };\n  return new Parser(\n    parsers.length === 1 ? parsers[0].parser : all2,\n    createParserContext(\"all\", void 0, ...parsers)\n  );\n}\nfunction string(str) {\n  const string2 = (state) => {\n    if (state.offset >= state.src.length) {\n      return state.err(void 0);\n    }\n    const s = state.src.slice(state.offset, state.offset + str.length);\n    if (s === str) {\n      return state.ok(s, s.length);\n    }\n    mergeErrorState(state);\n    return state.err(void 0);\n  };\n  return new Parser(\n    string2,\n    createParserContext(\"string\", void 0, str)\n  );\n}\nfunction regex(r, matchFunction = (m) => m == null ? void 0 : m[0]) {\n  const flags = r.flags.replace(/y/g, \"\");\n  const sticky = new RegExp(r, flags + \"y\");\n  const regex2 = (state) => {\n    if (state.offset >= state.src.length) {\n      return state.err(void 0);\n    }\n    sticky.lastIndex = state.offset;\n    const match = matchFunction(state.src.match(sticky));\n    if (match) {\n      return state.ok(match, sticky.lastIndex - state.offset);\n    } else if (match === \"\") {\n      return state.ok(void 0);\n    }\n    mergeErrorState(state);\n    return state.err(void 0);\n  };\n  return new Parser(\n    regex2,\n    createParserContext(\"regex\", void 0, r)\n  );\n}\nconst WHITESPACE = /\\s*/y;\nconst trimStateWhitespace = (state) => {\n  var _a;\n  if (state.offset >= state.src.length) {\n    return state;\n  }\n  WHITESPACE.lastIndex = state.offset;\n  const match = ((_a = state.src.match(WHITESPACE)) == null ? void 0 : _a[0]) ?? \"\";\n  return state.ok(state.value, match.length);\n};\nconst whitespace = regex(/\\s*/);\nwhitespace.context.name = \"whitespace\";\nexport {\n  Parser,\n  all,\n  any,\n  eof,\n  getLazyParser,\n  lazy,\n  mergeErrorState,\n  regex,\n  string,\n  whitespace\n};\n//# sourceMappingURL=parse.js.map\n","var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { regex, any, string, all, lazy, eof, Parser } from \"./parse.js\";\nimport \"chalk\";\nvar __defProp2 = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp2(target, key, result);\n  return result;\n};\nconst operatorToType = {\n  \"|\": \"alternation\",\n  \",\": \"concatenation\",\n  \"-\": \"minus\",\n  \"<<\": \"skip\",\n  \">>\": \"next\",\n  \"*\": \"many\",\n  \"+\": \"many1\",\n  \"?\": \"optional\",\n  \"?w\": \"optionalWhitespace\"\n};\nconst reduceBinaryExpression = ([left, rightExpression]) => {\n  if (rightExpression.length === 0) {\n    return left;\n  }\n  return rightExpression.reduce((acc, [op, right]) => {\n    return {\n      type: operatorToType[op],\n      value: [acc, right]\n    };\n  }, left);\n};\nconst mapFactor = ([term, op]) => {\n  if (op === void 0) {\n    return term;\n  }\n  const type = operatorToType[op];\n  return {\n    type,\n    value: term\n  };\n};\nconst defaultOptions = {\n  debug: false,\n  comments: true\n};\nclass EBNFGrammar {\n  constructor(options) {\n    __publicField(this, \"options\");\n    this.options = {\n      ...defaultOptions,\n      ...options ?? {}\n    };\n  }\n  identifier() {\n    return regex(/[_a-zA-Z][_a-zA-Z0-9]*/).trim();\n  }\n  literal() {\n    return this.trimBigComment(\n      any(\n        regex(/[^\"]+/).wrap(string('\"'), string('\"')),\n        regex(/[^']+/).wrap(string(\"'\"), string(\"'\"))\n      ).map((value) => {\n        return {\n          type: \"literal\",\n          value\n        };\n      })\n    );\n  }\n  epsilon() {\n    return any(string(\"epsilon\"), string(\"\")).trim().map((value) => {\n      return {\n        type: \"epsilon\",\n        value: void 0\n      };\n    });\n  }\n  nonterminal() {\n    return this.identifier().map((value) => {\n      return {\n        type: \"nonterminal\",\n        value\n      };\n    });\n  }\n  bigComment() {\n    return regex(/\\/\\*[^\\*]*\\*\\//).trim();\n  }\n  comment() {\n    return regex(/\\/\\/.*/).or(this.bigComment()).trim();\n  }\n  trimBigComment(e) {\n    return e.trim(this.bigComment().many(), false).map(([left, expression, right]) => {\n      expression.comment = {\n        left,\n        right\n      };\n      return expression;\n    });\n  }\n  group() {\n    return this.rhs().trim().wrap(string(\"(\"), string(\")\")).map((value) => {\n      return {\n        type: \"group\",\n        value\n      };\n    });\n  }\n  regex() {\n    return regex(/[^\\/]*/).wrap(string(\"/\"), string(\"/\")).then(regex(/[gimuy]*/).opt()).map(([r, flags]) => {\n      return {\n        type: \"regex\",\n        value: new RegExp(r, flags)\n      };\n    });\n  }\n  optionalGroup() {\n    return this.rhs().trim().wrap(string(\"[\"), string(\"]\")).map((value) => {\n      return {\n        type: \"optional\",\n        value\n      };\n    });\n  }\n  manyGroup() {\n    return this.rhs().trim().wrap(string(\"{\"), string(\"}\")).map((value) => {\n      return {\n        type: \"many\",\n        value\n      };\n    });\n  }\n  lhs() {\n    return this.identifier();\n  }\n  term() {\n    return any(\n      this.epsilon(),\n      this.group(),\n      this.optionalGroup(),\n      this.manyGroup(),\n      this.nonterminal(),\n      this.literal(),\n      this.regex()\n    );\n  }\n  factor() {\n    return this.trimBigComment(\n      all(\n        this.term(),\n        any(\n          string(\"?w\").trim(),\n          string(\"?\").trim(),\n          string(\"*\").trim(),\n          string(\"+\").trim()\n        ).opt()\n      ).map(mapFactor)\n    );\n  }\n  binaryFactor() {\n    return all(\n      this.factor(),\n      all(\n        any(string(\"<<\").trim(), string(\">>\").trim(), string(\"-\").trim()),\n        this.factor()\n      ).many()\n    ).map(reduceBinaryExpression);\n  }\n  concatenation() {\n    return this.binaryFactor().sepBy(string(\",\").trim()).map((value) => {\n      if (value.length === 1) {\n        return value[0];\n      }\n      return {\n        type: \"concatenation\",\n        value\n      };\n    });\n  }\n  alternation() {\n    return this.concatenation().sepBy(string(\"|\").trim()).map((value) => {\n      if (value.length === 1) {\n        return value[0];\n      }\n      return {\n        type: \"alternation\",\n        value\n      };\n    });\n  }\n  rhs() {\n    return this.alternation();\n  }\n  productionRule() {\n    return all(\n      this.lhs(),\n      string(\"=\").trim(),\n      this.rhs(),\n      any(string(\";\"), string(\".\")).trim()\n    ).map(([name, , expression]) => {\n      return { name, expression };\n    });\n  }\n  grammar() {\n    return this.productionRule().trim(this.comment().many(), false).map(([above, rule, below]) => {\n      rule.comment = {\n        above,\n        below\n      };\n      return rule;\n    }).many(1);\n  }\n}\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"bigComment\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"comment\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"group\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"regex\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"optionalGroup\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"manyGroup\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"lhs\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"term\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"factor\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"binaryFactor\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"concatenation\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"alternation\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"rhs\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"productionRule\", 1);\n__decorateClass([\n  lazy\n], EBNFGrammar.prototype, \"grammar\", 1);\nfunction topologicalSort(ast) {\n  const visited = /* @__PURE__ */ new Set();\n  const order = [];\n  function visit(node, stack) {\n    if (stack.has(node) || visited.has(node)) {\n      return;\n    }\n    stack.add(node);\n    const productionRule = ast.get(node);\n    if (!productionRule) {\n      return;\n    }\n    const expr = productionRule.expression;\n    if (expr.type === \"nonterminal\") {\n      visit(expr.value, stack);\n    } else if (expr.value instanceof Array) {\n      for (const child of expr.value) {\n        if (child.type === \"nonterminal\") {\n          visit(child.value, stack);\n        }\n      }\n    }\n    visited.add(node);\n    stack.delete(node);\n    order.unshift(ast.get(node));\n  }\n  for (const [name] of ast) {\n    visit(name, /* @__PURE__ */ new Set());\n  }\n  const newAST = /* @__PURE__ */ new Map();\n  for (const rule of order) {\n    newAST.set(rule.name, rule);\n  }\n  return newAST;\n}\nconst findCommonPrefix = (e1, e2) => {\n  if (!(e1 == null ? void 0 : e1.type) || !(e2 == null ? void 0 : e2.type) || e1.type !== e2.type) {\n    return void 0;\n  }\n  switch (e1.type) {\n    case \"literal\":\n    case \"nonterminal\": {\n      if (e1.value !== e2.value) {\n        return void 0;\n      } else {\n        return [e1, { type: \"epsilon\" }, { type: \"epsilon\" }];\n      }\n    }\n    case \"group\":\n    case \"optional\":\n    case \"optionalWhitespace\":\n    case \"many\":\n    case \"many1\": {\n      const common = findCommonPrefix(e1.value, e2.value);\n      if (!common) {\n        return void 0;\n      } else {\n        return [\n          {\n            type: e1.type,\n            value: common[0]\n          },\n          {\n            type: e1.type,\n            value: common[1]\n          },\n          {\n            type: e1.type,\n            value: common[2]\n          }\n        ];\n      }\n    }\n    case \"concatenation\": {\n      const commons = e1.value.map(\n        (_, i) => findCommonPrefix(e1.value[i], e2.value[i])\n      );\n      if (commons.some((x) => x === void 0)) {\n        return void 0;\n      }\n      const prefixes = commons.map((x) => x[0]);\n      const e1s = commons.map((x) => x[1]);\n      const e2s = commons.map((x) => x[2]);\n      const startIx = prefixes.lastIndexOf(null);\n      if (startIx === prefixes.length - 1) {\n        return void 0;\n      }\n      const prefix = prefixes.slice(startIx + 1);\n      return [\n        {\n          type: \"concatenation\",\n          value: prefix\n        },\n        {\n          type: \"concatenation\",\n          value: e1s\n        },\n        {\n          type: \"concatenation\",\n          value: e2s\n        }\n      ];\n    }\n    case \"alternation\":\n      for (const e of e1.value) {\n        const common = findCommonPrefix(e, e2);\n        if (common) {\n          return common;\n        }\n      }\n      for (const e of e2.value) {\n        const common = findCommonPrefix(e1, e);\n        if (common) {\n          return common;\n        }\n      }\n      return void 0;\n  }\n  return void 0;\n};\nconst comparePrefix = (prefix, expr) => {\n  if (prefix.type !== expr.type) {\n    return false;\n  }\n  switch (prefix.type) {\n    case \"literal\":\n    case \"nonterminal\":\n      return prefix.value === expr.value;\n    case \"group\":\n    case \"optional\":\n    case \"many\":\n    case \"many1\":\n      return comparePrefix(prefix.value, expr.value);\n    case \"minus\":\n    case \"skip\":\n    case \"next\":\n      return comparePrefix(prefix.value[0], expr.value[0]) && comparePrefix(prefix.value[1], expr.value[1]);\n    case \"concatenation\":\n      return prefix.value.every((e, i) => comparePrefix(e, expr.value[i]));\n    case \"alternation\":\n      return prefix.value.some((e, i) => comparePrefix(e, expr.value[i]));\n    case \"epsilon\":\n      return true;\n  }\n};\nfunction rewriteTreeLeftRecursion(name, expr) {\n  const prefixMap = /* @__PURE__ */ new Map();\n  let commonPrefix = null;\n  for (let i = 0; i < expr.value.length - 1; i++) {\n    const e1 = expr.value[i];\n    const e2 = expr.value[i + 1];\n    const common = findCommonPrefix(e1, e2);\n    if (common) {\n      const [prefix, te1, te2] = common;\n      if (commonPrefix !== null && comparePrefix(prefix, commonPrefix)) {\n        prefixMap.get(commonPrefix).push(te2);\n      } else {\n        prefixMap.set(prefix, [te1, te2]);\n        commonPrefix = prefix;\n      }\n      if (i === expr.value.length - 2) {\n        expr.value.shift();\n      }\n      expr.value.shift();\n      i -= 1;\n    }\n  }\n  for (const [prefix, expressions] of prefixMap) {\n    const alternation = {\n      type: \"alternation\",\n      value: expressions\n    };\n    const newExpr = {\n      type: \"concatenation\",\n      value: [\n        {\n          type: \"group\",\n          value: alternation\n        },\n        {\n          type: \"group\",\n          value: prefix\n        }\n      ]\n    };\n    expr.value.push(newExpr);\n  }\n}\nconst removeDirectLeftRecursionProduction = (name, expr, tailName) => {\n  const head = [];\n  const tail = [];\n  const APrime = {\n    type: \"nonterminal\",\n    value: tailName\n  };\n  for (let i = 0; i < expr.value.length; i++) {\n    const e = expr.value[i];\n    if (e.type === \"concatenation\" && e.value[0].value === name) {\n      tail.push({\n        type: \"concatenation\",\n        value: [...e.value.slice(1), APrime]\n      });\n    } else {\n      head.push({\n        type: \"concatenation\",\n        value: [e, APrime]\n      });\n    }\n  }\n  if (tail.length === 0) {\n    return [void 0, void 0];\n  }\n  tail.push({\n    type: \"epsilon\"\n  });\n  return [\n    {\n      type: \"alternation\",\n      value: head\n    },\n    {\n      type: \"alternation\",\n      value: tail\n    }\n  ];\n};\nfunction removeDirectLeftRecursion(ast) {\n  const newNodes = /* @__PURE__ */ new Map();\n  let uniqueIndex = 0;\n  for (const [name, productionRule] of ast) {\n    const { expression } = productionRule;\n    if (expression.type === \"alternation\") {\n      const tailName = `${name}_${uniqueIndex++}`;\n      const [head, tail] = removeDirectLeftRecursionProduction(\n        name,\n        expression,\n        tailName\n      );\n      if (head) {\n        newNodes.set(tailName, {\n          name: tailName,\n          expression: tail\n        });\n        newNodes.set(name, {\n          name,\n          expression: head,\n          comment: productionRule.comment\n        });\n      }\n    }\n  }\n  if (newNodes.size === 0) {\n    return ast;\n  }\n  for (const [name, productionRule] of newNodes) {\n    ast.set(name, productionRule);\n  }\n  for (const [name, productionRule] of ast) {\n    const { expression } = productionRule;\n    if (expression.type === \"alternation\") {\n      rewriteTreeLeftRecursion(name, expression);\n    }\n  }\n}\nfunction removeIndirectLeftRecursion(ast) {\n  for (const [name, expression] of ast) {\n  }\n}\nfunction removeAllLeftRecursion(ast) {\n  const newAST = topologicalSort(ast);\n  removeDirectLeftRecursion(newAST);\n  return newAST;\n}\nfunction generateASTFromEBNF(input) {\n  const parser = new EBNFGrammar().grammar().eof();\n  const parsed = parser.parse(input);\n  if (!parsed) {\n    return [parser];\n  }\n  const ast = parsed.reduce((acc, productionRule, ix) => {\n    return acc.set(productionRule.name, productionRule);\n  }, /* @__PURE__ */ new Map());\n  return [parser, ast];\n}\nfunction generateParserFromAST(ast) {\n  function generateParser(name, expr) {\n    var _a, _b;\n    switch (expr.type) {\n      case \"literal\":\n        return string(expr.value);\n      case \"nonterminal\":\n        const l = Parser.lazy(() => {\n          return nonterminals[expr.value];\n        });\n        l.context.name = expr.value;\n        return l;\n      case \"epsilon\":\n        return eof().opt();\n      case \"group\":\n        return generateParser(name, expr.value);\n      case \"regex\":\n        return regex(expr.value);\n      case \"optionalWhitespace\":\n        return generateParser(name, expr.value).trim();\n      case \"optional\":\n        return generateParser(name, expr.value).opt();\n      case \"many\":\n        return generateParser(name, expr.value).many();\n      case \"many1\":\n        return generateParser(name, expr.value).many(1);\n      case \"skip\":\n        return generateParser(name, expr.value[0]).skip(\n          generateParser(name, expr.value[1])\n        );\n      case \"next\":\n        return generateParser(name, expr.value[0]).next(\n          generateParser(name, expr.value[1])\n        );\n      case \"minus\":\n        return generateParser(name, expr.value[0]).not(\n          generateParser(name, expr.value[1])\n        );\n      case \"concatenation\": {\n        const parsers = expr.value.map((x) => generateParser(name, x));\n        if (((_b = (_a = parsers.at(-1)) == null ? void 0 : _a.context) == null ? void 0 : _b.name) === \"eof\") {\n          parsers.pop();\n        }\n        return all(...parsers);\n      }\n      case \"alternation\": {\n        return any(...expr.value.map((x) => generateParser(name, x)));\n      }\n    }\n  }\n  const nonterminals = {};\n  for (const [name, productionRule] of ast.entries()) {\n    nonterminals[name] = generateParser(name, productionRule.expression);\n  }\n  return nonterminals;\n}\nfunction generateParserFromEBNF(input, optimizeGraph = false) {\n  let [parser, ast] = generateASTFromEBNF(input);\n  if (optimizeGraph) {\n    ast = removeAllLeftRecursion(ast);\n  }\n  const nonterminals = generateParserFromAST(ast);\n  return [nonterminals, ast];\n}\nexport {\n  EBNFGrammar,\n  comparePrefix,\n  findCommonPrefix,\n  generateASTFromEBNF,\n  generateParserFromAST,\n  generateParserFromEBNF,\n  removeAllLeftRecursion,\n  removeDirectLeftRecursion,\n  removeIndirectLeftRecursion,\n  rewriteTreeLeftRecursion,\n  topologicalSort\n};\n//# sourceMappingURL=ebnf.js.map\n","import { generateASTFromEBNF, topologicalSort } from \"@mkbabb/parse-that/ebnf\";\n\nexport function locStart(node: object): number {\n    return 0;\n}\nexport function locEnd(node: object): number {\n    return 0;\n}\nexport function preprocess(text: string, options: object): string {\n    return text;\n}\n\nexport function parse(text: string, parsers: object, options: object) {\n    const [parser, ast] = generateASTFromEBNF(text);\n\n    if (parser.state.isError) {\n        throw new Error(`Error parsing EBNF: ${parser.state}`, {\n            cause: parser,\n        });\n    }\n\n    let prettierAST;\n    // @ts-ignore\n    if (options.sort) {\n        prettierAST = [...topologicalSort(ast).entries()].reverse();\n    } else {\n        prettierAST = [...ast.entries()];\n    }\n\n    return prettierAST\n        .filter(([key]) => key)\n        .reduce((acc, [key, value]) => {\n            return acc.set(key, value);\n        }, new Map());\n}\n","(function (factory) {\n  if (typeof exports === \"object\" && typeof module === \"object\") {\n    module.exports = factory();\n  } else if (typeof define === \"function\" && define.amd) {\n    define(factory);\n  } else {\n    var root =\n      typeof globalThis !== \"undefined\"\n        ? globalThis\n        : typeof global !== \"undefined\"\n        ? global\n        : typeof self !== \"undefined\"\n        ? self\n        : this || {};\n    root.doc = factory();\n  }\n})(function() {\n  \"use strict\";\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n\n  // dist/_doc.js.umd.js\n  var require_doc_js_umd = __commonJS({\n    \"dist/_doc.js.umd.js\"(exports, module) {\n      var __create = Object.create;\n      var __defProp = Object.defineProperty;\n      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n      var __getOwnPropNames2 = Object.getOwnPropertyNames;\n      var __getProtoOf = Object.getPrototypeOf;\n      var __hasOwnProp = Object.prototype.hasOwnProperty;\n      var __esm = (fn, res) => function __init() {\n        return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;\n      };\n      var __commonJS2 = (cb, mod) => function __require() {\n        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = {\n          exports: {}\n        }).exports, mod), mod.exports;\n      };\n      var __export = (target, all) => {\n        for (var name in all)\n          __defProp(target, name, {\n            get: all[name],\n            enumerable: true\n          });\n      };\n      var __copyProps = (to, from, except, desc) => {\n        if (from && typeof from === \"object\" || typeof from === \"function\") {\n          for (let key of __getOwnPropNames2(from))\n            if (!__hasOwnProp.call(to, key) && key !== except)\n              __defProp(to, key, {\n                get: () => from[key],\n                enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n              });\n        }\n        return to;\n      };\n      var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n      }) : target, mod));\n      var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", {\n        value: true\n      }), mod);\n      var init_define_process = __esm({\n        \"<define:process>\"() {\n        }\n      });\n      var require_doc_builders = __commonJS2({\n        \"src/document/doc-builders.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          function concat(parts) {\n            if (false) {\n              for (const part of parts) {\n                assertDoc(part);\n              }\n            }\n            return {\n              type: \"concat\",\n              parts\n            };\n          }\n          function indent(contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"indent\",\n              contents\n            };\n          }\n          function align(widthOrString, contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"align\",\n              contents,\n              n: widthOrString\n            };\n          }\n          function group(contents) {\n            let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"group\",\n              id: opts.id,\n              contents,\n              break: Boolean(opts.shouldBreak),\n              expandedStates: opts.expandedStates\n            };\n          }\n          function dedentToRoot(contents) {\n            return align(Number.NEGATIVE_INFINITY, contents);\n          }\n          function markAsRoot(contents) {\n            return align({\n              type: \"root\"\n            }, contents);\n          }\n          function dedent(contents) {\n            return align(-1, contents);\n          }\n          function conditionalGroup(states, opts) {\n            return group(states[0], Object.assign(Object.assign({}, opts), {}, {\n              expandedStates: states\n            }));\n          }\n          function fill(parts) {\n            if (false) {\n              for (const part of parts) {\n                assertDoc(part);\n              }\n            }\n            return {\n              type: \"fill\",\n              parts\n            };\n          }\n          function ifBreak(breakContents, flatContents) {\n            let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (false) {\n              if (breakContents) {\n                assertDoc(breakContents);\n              }\n              if (flatContents) {\n                assertDoc(flatContents);\n              }\n            }\n            return {\n              type: \"if-break\",\n              breakContents,\n              flatContents,\n              groupId: opts.groupId\n            };\n          }\n          function indentIfBreak(contents, opts) {\n            return {\n              type: \"indent-if-break\",\n              contents,\n              groupId: opts.groupId,\n              negate: opts.negate\n            };\n          }\n          function lineSuffix(contents) {\n            if (false) {\n              assertDoc(contents);\n            }\n            return {\n              type: \"line-suffix\",\n              contents\n            };\n          }\n          var lineSuffixBoundary = {\n            type: \"line-suffix-boundary\"\n          };\n          var breakParent = {\n            type: \"break-parent\"\n          };\n          var trim = {\n            type: \"trim\"\n          };\n          var hardlineWithoutBreakParent = {\n            type: \"line\",\n            hard: true\n          };\n          var literallineWithoutBreakParent = {\n            type: \"line\",\n            hard: true,\n            literal: true\n          };\n          var line = {\n            type: \"line\"\n          };\n          var softline = {\n            type: \"line\",\n            soft: true\n          };\n          var hardline = concat([hardlineWithoutBreakParent, breakParent]);\n          var literalline = concat([literallineWithoutBreakParent, breakParent]);\n          var cursor = {\n            type: \"cursor\",\n            placeholder: Symbol(\"cursor\")\n          };\n          function join(sep, arr) {\n            const res = [];\n            for (let i = 0; i < arr.length; i++) {\n              if (i !== 0) {\n                res.push(sep);\n              }\n              res.push(arr[i]);\n            }\n            return concat(res);\n          }\n          function addAlignmentToDoc(doc, size, tabWidth) {\n            let aligned = doc;\n            if (size > 0) {\n              for (let i = 0; i < Math.floor(size / tabWidth); ++i) {\n                aligned = indent(aligned);\n              }\n              aligned = align(size % tabWidth, aligned);\n              aligned = align(Number.NEGATIVE_INFINITY, aligned);\n            }\n            return aligned;\n          }\n          function label(label2, contents) {\n            return {\n              type: \"label\",\n              label: label2,\n              contents\n            };\n          }\n          module2.exports = {\n            concat,\n            join,\n            line,\n            softline,\n            hardline,\n            literalline,\n            group,\n            conditionalGroup,\n            fill,\n            lineSuffix,\n            lineSuffixBoundary,\n            cursor,\n            breakParent,\n            ifBreak,\n            trim,\n            indent,\n            indentIfBreak,\n            align,\n            addAlignmentToDoc,\n            markAsRoot,\n            dedentToRoot,\n            dedent,\n            hardlineWithoutBreakParent,\n            literallineWithoutBreakParent,\n            label\n          };\n        }\n      });\n      var require_end_of_line = __commonJS2({\n        \"src/common/end-of-line.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          function guessEndOfLine(text) {\n            const index = text.indexOf(\"\\r\");\n            if (index >= 0) {\n              return text.charAt(index + 1) === \"\\n\" ? \"crlf\" : \"cr\";\n            }\n            return \"lf\";\n          }\n          function convertEndOfLineToChars(value) {\n            switch (value) {\n              case \"cr\":\n                return \"\\r\";\n              case \"crlf\":\n                return \"\\r\\n\";\n              default:\n                return \"\\n\";\n            }\n          }\n          function countEndOfLineChars(text, eol) {\n            let regex;\n            switch (eol) {\n              case \"\\n\":\n                regex = /\\n/g;\n                break;\n              case \"\\r\":\n                regex = /\\r/g;\n                break;\n              case \"\\r\\n\":\n                regex = /\\r\\n/g;\n                break;\n              default:\n                throw new Error(`Unexpected \"eol\" ${JSON.stringify(eol)}.`);\n            }\n            const endOfLines = text.match(regex);\n            return endOfLines ? endOfLines.length : 0;\n          }\n          function normalizeEndOfLine(text) {\n            return text.replace(/\\r\\n?/g, \"\\n\");\n          }\n          module2.exports = {\n            guessEndOfLine,\n            convertEndOfLineToChars,\n            countEndOfLineChars,\n            normalizeEndOfLine\n          };\n        }\n      });\n      var require_get_last = __commonJS2({\n        \"src/utils/get-last.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var getLast = (arr) => arr[arr.length - 1];\n          module2.exports = getLast;\n        }\n      });\n      function ansiRegex() {\n        let {\n          onlyFirst = false\n        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const pattern = [\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"].join(\"|\");\n        return new RegExp(pattern, onlyFirst ? void 0 : \"g\");\n      }\n      var init_ansi_regex = __esm({\n        \"node_modules/strip-ansi/node_modules/ansi-regex/index.js\"() {\n          init_define_process();\n        }\n      });\n      function stripAnsi(string) {\n        if (typeof string !== \"string\") {\n          throw new TypeError(`Expected a \\`string\\`, got \\`${typeof string}\\``);\n        }\n        return string.replace(ansiRegex(), \"\");\n      }\n      var init_strip_ansi = __esm({\n        \"node_modules/strip-ansi/index.js\"() {\n          init_define_process();\n          init_ansi_regex();\n        }\n      });\n      function isFullwidthCodePoint(codePoint) {\n        if (!Number.isInteger(codePoint)) {\n          return false;\n        }\n        return codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141);\n      }\n      var init_is_fullwidth_code_point = __esm({\n        \"node_modules/is-fullwidth-code-point/index.js\"() {\n          init_define_process();\n        }\n      });\n      var require_emoji_regex = __commonJS2({\n        \"node_modules/emoji-regex/index.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          module2.exports = function() {\n            return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|(?:\\uD83E\\uDDD1\\uD83C\\uDFFF\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C\\uDFFB(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))?|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC)?|(?:\\uD83D\\uDC69(?:\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC69(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83E\\uDDD1(?:\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDE36\\u200D\\uD83C\\uDF2B|\\uD83C\\uDFF3\\uFE0F\\u200D\\u26A7|\\uD83D\\uDC3B\\u200D\\u2744|(?:(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\uD83C\\uDFF4\\u200D\\u2620|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])\\u200D[\\u2640\\u2642]|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u2600-\\u2604\\u260E\\u2611\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26B0\\u26B1\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0\\u26F1\\u26F4\\u26F7\\u26F8\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]|\\uD83D[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3])\\uFE0F|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB|\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83D\\uDC69(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC08\\u200D\\u2B1B|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79)|\\uD83D\\uDC41\\uFE0F|\\uD83C\\uDFF3\\uFE0F|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\u2764\\uFE0F|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF4|(?:[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270C\\u270D]|\\uD83D[\\uDD74\\uDD90])(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC08\\uDC15\\uDC3B\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE2E\\uDE35\\uDE36\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5]|\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD]|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF]|[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD1D\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78\\uDD7A-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCB\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6]|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDD77\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n          };\n        }\n      });\n      var string_width_exports = {};\n      __export(string_width_exports, {\n        default: () => stringWidth\n      });\n      function stringWidth(string) {\n        if (typeof string !== \"string\" || string.length === 0) {\n          return 0;\n        }\n        string = stripAnsi(string);\n        if (string.length === 0) {\n          return 0;\n        }\n        string = string.replace((0, import_emoji_regex.default)(), \"  \");\n        let width = 0;\n        for (let index = 0; index < string.length; index++) {\n          const codePoint = string.codePointAt(index);\n          if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {\n            continue;\n          }\n          if (codePoint >= 768 && codePoint <= 879) {\n            continue;\n          }\n          if (codePoint > 65535) {\n            index++;\n          }\n          width += isFullwidthCodePoint(codePoint) ? 2 : 1;\n        }\n        return width;\n      }\n      var import_emoji_regex;\n      var init_string_width = __esm({\n        \"node_modules/string-width/index.js\"() {\n          init_define_process();\n          init_strip_ansi();\n          init_is_fullwidth_code_point();\n          import_emoji_regex = __toESM(require_emoji_regex());\n        }\n      });\n      var require_get_string_width = __commonJS2({\n        \"src/utils/get-string-width.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var stringWidth2 = (init_string_width(), __toCommonJS(string_width_exports)).default;\n          var notAsciiRegex = /[^\\x20-\\x7F]/;\n          function getStringWidth(text) {\n            if (!text) {\n              return 0;\n            }\n            if (!notAsciiRegex.test(text)) {\n              return text.length;\n            }\n            return stringWidth2(text);\n          }\n          module2.exports = getStringWidth;\n        }\n      });\n      var require_doc_utils = __commonJS2({\n        \"src/document/doc-utils.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var getLast = require_get_last();\n          var {\n            literalline,\n            join\n          } = require_doc_builders();\n          var isConcat = (doc) => Array.isArray(doc) || doc && doc.type === \"concat\";\n          var getDocParts = (doc) => {\n            if (Array.isArray(doc)) {\n              return doc;\n            }\n            if (doc.type !== \"concat\" && doc.type !== \"fill\") {\n              throw new Error(\"Expect doc type to be `concat` or `fill`.\");\n            }\n            return doc.parts;\n          };\n          var traverseDocOnExitStackMarker = {};\n          function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n            const docsStack = [doc];\n            while (docsStack.length > 0) {\n              const doc2 = docsStack.pop();\n              if (doc2 === traverseDocOnExitStackMarker) {\n                onExit(docsStack.pop());\n                continue;\n              }\n              if (onExit) {\n                docsStack.push(doc2, traverseDocOnExitStackMarker);\n              }\n              if (!onEnter || onEnter(doc2) !== false) {\n                if (isConcat(doc2) || doc2.type === \"fill\") {\n                  const parts = getDocParts(doc2);\n                  for (let ic = parts.length, i = ic - 1; i >= 0; --i) {\n                    docsStack.push(parts[i]);\n                  }\n                } else if (doc2.type === \"if-break\") {\n                  if (doc2.flatContents) {\n                    docsStack.push(doc2.flatContents);\n                  }\n                  if (doc2.breakContents) {\n                    docsStack.push(doc2.breakContents);\n                  }\n                } else if (doc2.type === \"group\" && doc2.expandedStates) {\n                  if (shouldTraverseConditionalGroups) {\n                    for (let ic = doc2.expandedStates.length, i = ic - 1; i >= 0; --i) {\n                      docsStack.push(doc2.expandedStates[i]);\n                    }\n                  } else {\n                    docsStack.push(doc2.contents);\n                  }\n                } else if (doc2.contents) {\n                  docsStack.push(doc2.contents);\n                }\n              }\n            }\n          }\n          function mapDoc(doc, cb) {\n            const mapped = /* @__PURE__ */ new Map();\n            return rec(doc);\n            function rec(doc2) {\n              if (mapped.has(doc2)) {\n                return mapped.get(doc2);\n              }\n              const result = process2(doc2);\n              mapped.set(doc2, result);\n              return result;\n            }\n            function process2(doc2) {\n              if (Array.isArray(doc2)) {\n                return cb(doc2.map(rec));\n              }\n              if (doc2.type === \"concat\" || doc2.type === \"fill\") {\n                const parts = doc2.parts.map(rec);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  parts\n                }));\n              }\n              if (doc2.type === \"if-break\") {\n                const breakContents = doc2.breakContents && rec(doc2.breakContents);\n                const flatContents = doc2.flatContents && rec(doc2.flatContents);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  breakContents,\n                  flatContents\n                }));\n              }\n              if (doc2.type === \"group\" && doc2.expandedStates) {\n                const expandedStates = doc2.expandedStates.map(rec);\n                const contents = expandedStates[0];\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  contents,\n                  expandedStates\n                }));\n              }\n              if (doc2.contents) {\n                const contents = rec(doc2.contents);\n                return cb(Object.assign(Object.assign({}, doc2), {}, {\n                  contents\n                }));\n              }\n              return cb(doc2);\n            }\n          }\n          function findInDoc(doc, fn, defaultValue) {\n            let result = defaultValue;\n            let hasStopped = false;\n            function findInDocOnEnterFn(doc2) {\n              const maybeResult = fn(doc2);\n              if (maybeResult !== void 0) {\n                hasStopped = true;\n                result = maybeResult;\n              }\n              if (hasStopped) {\n                return false;\n              }\n            }\n            traverseDoc(doc, findInDocOnEnterFn);\n            return result;\n          }\n          function willBreakFn(doc) {\n            if (doc.type === \"group\" && doc.break) {\n              return true;\n            }\n            if (doc.type === \"line\" && doc.hard) {\n              return true;\n            }\n            if (doc.type === \"break-parent\") {\n              return true;\n            }\n          }\n          function willBreak(doc) {\n            return findInDoc(doc, willBreakFn, false);\n          }\n          function breakParentGroup(groupStack) {\n            if (groupStack.length > 0) {\n              const parentGroup = getLast(groupStack);\n              if (!parentGroup.expandedStates && !parentGroup.break) {\n                parentGroup.break = \"propagated\";\n              }\n            }\n            return null;\n          }\n          function propagateBreaks(doc) {\n            const alreadyVisitedSet = /* @__PURE__ */ new Set();\n            const groupStack = [];\n            function propagateBreaksOnEnterFn(doc2) {\n              if (doc2.type === \"break-parent\") {\n                breakParentGroup(groupStack);\n              }\n              if (doc2.type === \"group\") {\n                groupStack.push(doc2);\n                if (alreadyVisitedSet.has(doc2)) {\n                  return false;\n                }\n                alreadyVisitedSet.add(doc2);\n              }\n            }\n            function propagateBreaksOnExitFn(doc2) {\n              if (doc2.type === \"group\") {\n                const group = groupStack.pop();\n                if (group.break) {\n                  breakParentGroup(groupStack);\n                }\n              }\n            }\n            traverseDoc(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn, true);\n          }\n          function removeLinesFn(doc) {\n            if (doc.type === \"line\" && !doc.hard) {\n              return doc.soft ? \"\" : \" \";\n            }\n            if (doc.type === \"if-break\") {\n              return doc.flatContents || \"\";\n            }\n            return doc;\n          }\n          function removeLines(doc) {\n            return mapDoc(doc, removeLinesFn);\n          }\n          var isHardline = (doc, nextDoc) => doc && doc.type === \"line\" && doc.hard && nextDoc && nextDoc.type === \"break-parent\";\n          function stripDocTrailingHardlineFromDoc(doc) {\n            if (!doc) {\n              return doc;\n            }\n            if (isConcat(doc) || doc.type === \"fill\") {\n              const parts = getDocParts(doc);\n              while (parts.length > 1 && isHardline(...parts.slice(-2))) {\n                parts.length -= 2;\n              }\n              if (parts.length > 0) {\n                const lastPart = stripDocTrailingHardlineFromDoc(getLast(parts));\n                parts[parts.length - 1] = lastPart;\n              }\n              return Array.isArray(doc) ? parts : Object.assign(Object.assign({}, doc), {}, {\n                parts\n              });\n            }\n            switch (doc.type) {\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"group\":\n              case \"line-suffix\":\n              case \"label\": {\n                const contents = stripDocTrailingHardlineFromDoc(doc.contents);\n                return Object.assign(Object.assign({}, doc), {}, {\n                  contents\n                });\n              }\n              case \"if-break\": {\n                const breakContents = stripDocTrailingHardlineFromDoc(doc.breakContents);\n                const flatContents = stripDocTrailingHardlineFromDoc(doc.flatContents);\n                return Object.assign(Object.assign({}, doc), {}, {\n                  breakContents,\n                  flatContents\n                });\n              }\n            }\n            return doc;\n          }\n          function stripTrailingHardline(doc) {\n            return stripDocTrailingHardlineFromDoc(cleanDoc(doc));\n          }\n          function cleanDocFn(doc) {\n            switch (doc.type) {\n              case \"fill\":\n                if (doc.parts.every((part) => part === \"\")) {\n                  return \"\";\n                }\n                break;\n              case \"group\":\n                if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {\n                  return \"\";\n                }\n                if (doc.contents.type === \"group\" && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates) {\n                  return doc.contents;\n                }\n                break;\n              case \"align\":\n              case \"indent\":\n              case \"indent-if-break\":\n              case \"line-suffix\":\n                if (!doc.contents) {\n                  return \"\";\n                }\n                break;\n              case \"if-break\":\n                if (!doc.flatContents && !doc.breakContents) {\n                  return \"\";\n                }\n                break;\n            }\n            if (!isConcat(doc)) {\n              return doc;\n            }\n            const parts = [];\n            for (const part of getDocParts(doc)) {\n              if (!part) {\n                continue;\n              }\n              const [currentPart, ...restParts] = isConcat(part) ? getDocParts(part) : [part];\n              if (typeof currentPart === \"string\" && typeof getLast(parts) === \"string\") {\n                parts[parts.length - 1] += currentPart;\n              } else {\n                parts.push(currentPart);\n              }\n              parts.push(...restParts);\n            }\n            if (parts.length === 0) {\n              return \"\";\n            }\n            if (parts.length === 1) {\n              return parts[0];\n            }\n            return Array.isArray(doc) ? parts : Object.assign(Object.assign({}, doc), {}, {\n              parts\n            });\n          }\n          function cleanDoc(doc) {\n            return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));\n          }\n          function normalizeParts(parts) {\n            const newParts = [];\n            const restParts = parts.filter(Boolean);\n            while (restParts.length > 0) {\n              const part = restParts.shift();\n              if (!part) {\n                continue;\n              }\n              if (isConcat(part)) {\n                restParts.unshift(...getDocParts(part));\n                continue;\n              }\n              if (newParts.length > 0 && typeof getLast(newParts) === \"string\" && typeof part === \"string\") {\n                newParts[newParts.length - 1] += part;\n                continue;\n              }\n              newParts.push(part);\n            }\n            return newParts;\n          }\n          function normalizeDoc(doc) {\n            return mapDoc(doc, (currentDoc) => {\n              if (Array.isArray(currentDoc)) {\n                return normalizeParts(currentDoc);\n              }\n              if (!currentDoc.parts) {\n                return currentDoc;\n              }\n              return Object.assign(Object.assign({}, currentDoc), {}, {\n                parts: normalizeParts(currentDoc.parts)\n              });\n            });\n          }\n          function replaceEndOfLine(doc) {\n            return mapDoc(doc, (currentDoc) => typeof currentDoc === \"string\" && currentDoc.includes(\"\\n\") ? replaceTextEndOfLine(currentDoc) : currentDoc);\n          }\n          function replaceTextEndOfLine(text) {\n            let replacement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : literalline;\n            return join(replacement, text.split(\"\\n\")).parts;\n          }\n          function canBreakFn(doc) {\n            if (doc.type === \"line\") {\n              return true;\n            }\n          }\n          function canBreak(doc) {\n            return findInDoc(doc, canBreakFn, false);\n          }\n          module2.exports = {\n            isConcat,\n            getDocParts,\n            willBreak,\n            traverseDoc,\n            findInDoc,\n            mapDoc,\n            propagateBreaks,\n            removeLines,\n            stripTrailingHardline,\n            normalizeParts,\n            normalizeDoc,\n            cleanDoc,\n            replaceTextEndOfLine,\n            replaceEndOfLine,\n            canBreak\n          };\n        }\n      });\n      var require_doc_printer = __commonJS2({\n        \"src/document/doc-printer.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var {\n            convertEndOfLineToChars\n          } = require_end_of_line();\n          var getLast = require_get_last();\n          var getStringWidth = require_get_string_width();\n          var {\n            fill,\n            cursor,\n            indent\n          } = require_doc_builders();\n          var {\n            isConcat,\n            getDocParts\n          } = require_doc_utils();\n          var groupModeMap;\n          var MODE_BREAK = 1;\n          var MODE_FLAT = 2;\n          function rootIndent() {\n            return {\n              value: \"\",\n              length: 0,\n              queue: []\n            };\n          }\n          function makeIndent(ind, options) {\n            return generateInd(ind, {\n              type: \"indent\"\n            }, options);\n          }\n          function makeAlign(indent2, widthOrDoc, options) {\n            if (widthOrDoc === Number.NEGATIVE_INFINITY) {\n              return indent2.root || rootIndent();\n            }\n            if (widthOrDoc < 0) {\n              return generateInd(indent2, {\n                type: \"dedent\"\n              }, options);\n            }\n            if (!widthOrDoc) {\n              return indent2;\n            }\n            if (widthOrDoc.type === \"root\") {\n              return Object.assign(Object.assign({}, indent2), {}, {\n                root: indent2\n              });\n            }\n            const alignType = typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";\n            return generateInd(indent2, {\n              type: alignType,\n              n: widthOrDoc\n            }, options);\n          }\n          function generateInd(ind, newPart, options) {\n            const queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];\n            let value = \"\";\n            let length = 0;\n            let lastTabs = 0;\n            let lastSpaces = 0;\n            for (const part of queue) {\n              switch (part.type) {\n                case \"indent\":\n                  flush();\n                  if (options.useTabs) {\n                    addTabs(1);\n                  } else {\n                    addSpaces(options.tabWidth);\n                  }\n                  break;\n                case \"stringAlign\":\n                  flush();\n                  value += part.n;\n                  length += part.n.length;\n                  break;\n                case \"numberAlign\":\n                  lastTabs += 1;\n                  lastSpaces += part.n;\n                  break;\n                default:\n                  throw new Error(`Unexpected type '${part.type}'`);\n              }\n            }\n            flushSpaces();\n            return Object.assign(Object.assign({}, ind), {}, {\n              value,\n              length,\n              queue\n            });\n            function addTabs(count) {\n              value += \"\t\".repeat(count);\n              length += options.tabWidth * count;\n            }\n            function addSpaces(count) {\n              value += \" \".repeat(count);\n              length += count;\n            }\n            function flush() {\n              if (options.useTabs) {\n                flushTabs();\n              } else {\n                flushSpaces();\n              }\n            }\n            function flushTabs() {\n              if (lastTabs > 0) {\n                addTabs(lastTabs);\n              }\n              resetLast();\n            }\n            function flushSpaces() {\n              if (lastSpaces > 0) {\n                addSpaces(lastSpaces);\n              }\n              resetLast();\n            }\n            function resetLast() {\n              lastTabs = 0;\n              lastSpaces = 0;\n            }\n          }\n          function trim(out) {\n            if (out.length === 0) {\n              return 0;\n            }\n            let trimCount = 0;\n            while (out.length > 0 && typeof getLast(out) === \"string\" && /^[\\t ]*$/.test(getLast(out))) {\n              trimCount += out.pop().length;\n            }\n            if (out.length > 0 && typeof getLast(out) === \"string\") {\n              const trimmed = getLast(out).replace(/[\\t ]*$/, \"\");\n              trimCount += getLast(out).length - trimmed.length;\n              out[out.length - 1] = trimmed;\n            }\n            return trimCount;\n          }\n          function fits(next, restCommands, width, hasLineSuffix, mustBeFlat) {\n            let restIdx = restCommands.length;\n            const cmds = [next];\n            const out = [];\n            while (width >= 0) {\n              if (cmds.length === 0) {\n                if (restIdx === 0) {\n                  return true;\n                }\n                cmds.push(restCommands[--restIdx]);\n                continue;\n              }\n              const {\n                mode,\n                doc\n              } = cmds.pop();\n              if (typeof doc === \"string\") {\n                out.push(doc);\n                width -= getStringWidth(doc);\n              } else if (isConcat(doc) || doc.type === \"fill\") {\n                const parts = getDocParts(doc);\n                for (let i = parts.length - 1; i >= 0; i--) {\n                  cmds.push({\n                    mode,\n                    doc: parts[i]\n                  });\n                }\n              } else {\n                switch (doc.type) {\n                  case \"indent\":\n                  case \"align\":\n                  case \"indent-if-break\":\n                  case \"label\":\n                    cmds.push({\n                      mode,\n                      doc: doc.contents\n                    });\n                    break;\n                  case \"trim\":\n                    width += trim(out);\n                    break;\n                  case \"group\": {\n                    if (mustBeFlat && doc.break) {\n                      return false;\n                    }\n                    const groupMode = doc.break ? MODE_BREAK : mode;\n                    const contents = doc.expandedStates && groupMode === MODE_BREAK ? getLast(doc.expandedStates) : doc.contents;\n                    cmds.push({\n                      mode: groupMode,\n                      doc: contents\n                    });\n                    break;\n                  }\n                  case \"if-break\": {\n                    const groupMode = doc.groupId ? groupModeMap[doc.groupId] || MODE_FLAT : mode;\n                    const contents = groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;\n                    if (contents) {\n                      cmds.push({\n                        mode,\n                        doc: contents\n                      });\n                    }\n                    break;\n                  }\n                  case \"line\":\n                    if (mode === MODE_BREAK || doc.hard) {\n                      return true;\n                    }\n                    if (!doc.soft) {\n                      out.push(\" \");\n                      width--;\n                    }\n                    break;\n                  case \"line-suffix\":\n                    hasLineSuffix = true;\n                    break;\n                  case \"line-suffix-boundary\":\n                    if (hasLineSuffix) {\n                      return false;\n                    }\n                    break;\n                }\n              }\n            }\n            return false;\n          }\n          function printDocToString(doc, options) {\n            groupModeMap = {};\n            const width = options.printWidth;\n            const newLine = convertEndOfLineToChars(options.endOfLine);\n            let pos = 0;\n            const cmds = [{\n              ind: rootIndent(),\n              mode: MODE_BREAK,\n              doc\n            }];\n            const out = [];\n            let shouldRemeasure = false;\n            const lineSuffix = [];\n            while (cmds.length > 0) {\n              const {\n                ind,\n                mode,\n                doc: doc2\n              } = cmds.pop();\n              if (typeof doc2 === \"string\") {\n                const formatted = newLine !== \"\\n\" ? doc2.replace(/\\n/g, newLine) : doc2;\n                out.push(formatted);\n                pos += getStringWidth(formatted);\n              } else if (isConcat(doc2)) {\n                const parts = getDocParts(doc2);\n                for (let i = parts.length - 1; i >= 0; i--) {\n                  cmds.push({\n                    ind,\n                    mode,\n                    doc: parts[i]\n                  });\n                }\n              } else {\n                switch (doc2.type) {\n                  case \"cursor\":\n                    out.push(cursor.placeholder);\n                    break;\n                  case \"indent\":\n                    cmds.push({\n                      ind: makeIndent(ind, options),\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  case \"align\":\n                    cmds.push({\n                      ind: makeAlign(ind, doc2.n, options),\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  case \"trim\":\n                    pos -= trim(out);\n                    break;\n                  case \"group\":\n                    switch (mode) {\n                      case MODE_FLAT:\n                        if (!shouldRemeasure) {\n                          cmds.push({\n                            ind,\n                            mode: doc2.break ? MODE_BREAK : MODE_FLAT,\n                            doc: doc2.contents\n                          });\n                          break;\n                        }\n                      case MODE_BREAK: {\n                        shouldRemeasure = false;\n                        const next = {\n                          ind,\n                          mode: MODE_FLAT,\n                          doc: doc2.contents\n                        };\n                        const rem = width - pos;\n                        const hasLineSuffix = lineSuffix.length > 0;\n                        if (!doc2.break && fits(next, cmds, rem, hasLineSuffix)) {\n                          cmds.push(next);\n                        } else {\n                          if (doc2.expandedStates) {\n                            const mostExpanded = getLast(doc2.expandedStates);\n                            if (doc2.break) {\n                              cmds.push({\n                                ind,\n                                mode: MODE_BREAK,\n                                doc: mostExpanded\n                              });\n                              break;\n                            } else {\n                              for (let i = 1; i < doc2.expandedStates.length + 1; i++) {\n                                if (i >= doc2.expandedStates.length) {\n                                  cmds.push({\n                                    ind,\n                                    mode: MODE_BREAK,\n                                    doc: mostExpanded\n                                  });\n                                  break;\n                                } else {\n                                  const state = doc2.expandedStates[i];\n                                  const cmd = {\n                                    ind,\n                                    mode: MODE_FLAT,\n                                    doc: state\n                                  };\n                                  if (fits(cmd, cmds, rem, hasLineSuffix)) {\n                                    cmds.push(cmd);\n                                    break;\n                                  }\n                                }\n                              }\n                            }\n                          } else {\n                            cmds.push({\n                              ind,\n                              mode: MODE_BREAK,\n                              doc: doc2.contents\n                            });\n                          }\n                        }\n                        break;\n                      }\n                    }\n                    if (doc2.id) {\n                      groupModeMap[doc2.id] = getLast(cmds).mode;\n                    }\n                    break;\n                  case \"fill\": {\n                    const rem = width - pos;\n                    const {\n                      parts\n                    } = doc2;\n                    if (parts.length === 0) {\n                      break;\n                    }\n                    const [content, whitespace] = parts;\n                    const contentFlatCmd = {\n                      ind,\n                      mode: MODE_FLAT,\n                      doc: content\n                    };\n                    const contentBreakCmd = {\n                      ind,\n                      mode: MODE_BREAK,\n                      doc: content\n                    };\n                    const contentFits = fits(contentFlatCmd, [], rem, lineSuffix.length > 0, true);\n                    if (parts.length === 1) {\n                      if (contentFits) {\n                        cmds.push(contentFlatCmd);\n                      } else {\n                        cmds.push(contentBreakCmd);\n                      }\n                      break;\n                    }\n                    const whitespaceFlatCmd = {\n                      ind,\n                      mode: MODE_FLAT,\n                      doc: whitespace\n                    };\n                    const whitespaceBreakCmd = {\n                      ind,\n                      mode: MODE_BREAK,\n                      doc: whitespace\n                    };\n                    if (parts.length === 2) {\n                      if (contentFits) {\n                        cmds.push(whitespaceFlatCmd, contentFlatCmd);\n                      } else {\n                        cmds.push(whitespaceBreakCmd, contentBreakCmd);\n                      }\n                      break;\n                    }\n                    parts.splice(0, 2);\n                    const remainingCmd = {\n                      ind,\n                      mode,\n                      doc: fill(parts)\n                    };\n                    const secondContent = parts[0];\n                    const firstAndSecondContentFlatCmd = {\n                      ind,\n                      mode: MODE_FLAT,\n                      doc: [content, whitespace, secondContent]\n                    };\n                    const firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], rem, lineSuffix.length > 0, true);\n                    if (firstAndSecondContentFits) {\n                      cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);\n                    } else if (contentFits) {\n                      cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);\n                    } else {\n                      cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);\n                    }\n                    break;\n                  }\n                  case \"if-break\":\n                  case \"indent-if-break\": {\n                    const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;\n                    if (groupMode === MODE_BREAK) {\n                      const breakContents = doc2.type === \"if-break\" ? doc2.breakContents : doc2.negate ? doc2.contents : indent(doc2.contents);\n                      if (breakContents) {\n                        cmds.push({\n                          ind,\n                          mode,\n                          doc: breakContents\n                        });\n                      }\n                    }\n                    if (groupMode === MODE_FLAT) {\n                      const flatContents = doc2.type === \"if-break\" ? doc2.flatContents : doc2.negate ? indent(doc2.contents) : doc2.contents;\n                      if (flatContents) {\n                        cmds.push({\n                          ind,\n                          mode,\n                          doc: flatContents\n                        });\n                      }\n                    }\n                    break;\n                  }\n                  case \"line-suffix\":\n                    lineSuffix.push({\n                      ind,\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  case \"line-suffix-boundary\":\n                    if (lineSuffix.length > 0) {\n                      cmds.push({\n                        ind,\n                        mode,\n                        doc: {\n                          type: \"line\",\n                          hard: true\n                        }\n                      });\n                    }\n                    break;\n                  case \"line\":\n                    switch (mode) {\n                      case MODE_FLAT:\n                        if (!doc2.hard) {\n                          if (!doc2.soft) {\n                            out.push(\" \");\n                            pos += 1;\n                          }\n                          break;\n                        } else {\n                          shouldRemeasure = true;\n                        }\n                      case MODE_BREAK:\n                        if (lineSuffix.length > 0) {\n                          cmds.push({\n                            ind,\n                            mode,\n                            doc: doc2\n                          }, ...lineSuffix.reverse());\n                          lineSuffix.length = 0;\n                          break;\n                        }\n                        if (doc2.literal) {\n                          if (ind.root) {\n                            out.push(newLine, ind.root.value);\n                            pos = ind.root.length;\n                          } else {\n                            out.push(newLine);\n                            pos = 0;\n                          }\n                        } else {\n                          pos -= trim(out);\n                          out.push(newLine + ind.value);\n                          pos = ind.length;\n                        }\n                        break;\n                    }\n                    break;\n                  case \"label\":\n                    cmds.push({\n                      ind,\n                      mode,\n                      doc: doc2.contents\n                    });\n                    break;\n                  default:\n                }\n              }\n              if (cmds.length === 0 && lineSuffix.length > 0) {\n                cmds.push(...lineSuffix.reverse());\n                lineSuffix.length = 0;\n              }\n            }\n            const cursorPlaceholderIndex = out.indexOf(cursor.placeholder);\n            if (cursorPlaceholderIndex !== -1) {\n              const otherCursorPlaceholderIndex = out.indexOf(cursor.placeholder, cursorPlaceholderIndex + 1);\n              const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n              const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n              const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n              return {\n                formatted: beforeCursor + aroundCursor + afterCursor,\n                cursorNodeStart: beforeCursor.length,\n                cursorNodeText: aroundCursor\n              };\n            }\n            return {\n              formatted: out.join(\"\")\n            };\n          }\n          module2.exports = {\n            printDocToString\n          };\n        }\n      });\n      var require_doc_debug = __commonJS2({\n        \"src/document/doc-debug.js\"(exports2, module2) {\n          \"use strict\";\n          init_define_process();\n          var {\n            isConcat,\n            getDocParts\n          } = require_doc_utils();\n          function flattenDoc(doc) {\n            if (!doc) {\n              return \"\";\n            }\n            if (isConcat(doc)) {\n              const res = [];\n              for (const part of getDocParts(doc)) {\n                if (isConcat(part)) {\n                  res.push(...flattenDoc(part).parts);\n                } else {\n                  const flattened = flattenDoc(part);\n                  if (flattened !== \"\") {\n                    res.push(flattened);\n                  }\n                }\n              }\n              return {\n                type: \"concat\",\n                parts: res\n              };\n            }\n            if (doc.type === \"if-break\") {\n              return Object.assign(Object.assign({}, doc), {}, {\n                breakContents: flattenDoc(doc.breakContents),\n                flatContents: flattenDoc(doc.flatContents)\n              });\n            }\n            if (doc.type === \"group\") {\n              return Object.assign(Object.assign({}, doc), {}, {\n                contents: flattenDoc(doc.contents),\n                expandedStates: doc.expandedStates && doc.expandedStates.map(flattenDoc)\n              });\n            }\n            if (doc.type === \"fill\") {\n              return {\n                type: \"fill\",\n                parts: doc.parts.map(flattenDoc)\n              };\n            }\n            if (doc.contents) {\n              return Object.assign(Object.assign({}, doc), {}, {\n                contents: flattenDoc(doc.contents)\n              });\n            }\n            return doc;\n          }\n          function printDocToDebug(doc) {\n            const printedSymbols = /* @__PURE__ */ Object.create(null);\n            const usedKeysForSymbols = /* @__PURE__ */ new Set();\n            return printDoc(flattenDoc(doc));\n            function printDoc(doc2, index, parentParts) {\n              if (typeof doc2 === \"string\") {\n                return JSON.stringify(doc2);\n              }\n              if (isConcat(doc2)) {\n                const printed = getDocParts(doc2).map(printDoc).filter(Boolean);\n                return printed.length === 1 ? printed[0] : `[${printed.join(\", \")}]`;\n              }\n              if (doc2.type === \"line\") {\n                const withBreakParent = Array.isArray(parentParts) && parentParts[index + 1] && parentParts[index + 1].type === \"break-parent\";\n                if (doc2.literal) {\n                  return withBreakParent ? \"literalline\" : \"literallineWithoutBreakParent\";\n                }\n                if (doc2.hard) {\n                  return withBreakParent ? \"hardline\" : \"hardlineWithoutBreakParent\";\n                }\n                if (doc2.soft) {\n                  return \"softline\";\n                }\n                return \"line\";\n              }\n              if (doc2.type === \"break-parent\") {\n                const afterHardline = Array.isArray(parentParts) && parentParts[index - 1] && parentParts[index - 1].type === \"line\" && parentParts[index - 1].hard;\n                return afterHardline ? void 0 : \"breakParent\";\n              }\n              if (doc2.type === \"trim\") {\n                return \"trim\";\n              }\n              if (doc2.type === \"indent\") {\n                return \"indent(\" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"align\") {\n                return doc2.n === Number.NEGATIVE_INFINITY ? \"dedentToRoot(\" + printDoc(doc2.contents) + \")\" : doc2.n < 0 ? \"dedent(\" + printDoc(doc2.contents) + \")\" : doc2.n.type === \"root\" ? \"markAsRoot(\" + printDoc(doc2.contents) + \")\" : \"align(\" + JSON.stringify(doc2.n) + \", \" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"if-break\") {\n                return \"ifBreak(\" + printDoc(doc2.breakContents) + (doc2.flatContents ? \", \" + printDoc(doc2.flatContents) : \"\") + (doc2.groupId ? (!doc2.flatContents ? ', \"\"' : \"\") + `, { groupId: ${printGroupId(doc2.groupId)} }` : \"\") + \")\";\n              }\n              if (doc2.type === \"indent-if-break\") {\n                const optionsParts = [];\n                if (doc2.negate) {\n                  optionsParts.push(\"negate: true\");\n                }\n                if (doc2.groupId) {\n                  optionsParts.push(`groupId: ${printGroupId(doc2.groupId)}`);\n                }\n                const options = optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";\n                return `indentIfBreak(${printDoc(doc2.contents)}${options})`;\n              }\n              if (doc2.type === \"group\") {\n                const optionsParts = [];\n                if (doc2.break && doc2.break !== \"propagated\") {\n                  optionsParts.push(\"shouldBreak: true\");\n                }\n                if (doc2.id) {\n                  optionsParts.push(`id: ${printGroupId(doc2.id)}`);\n                }\n                const options = optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";\n                if (doc2.expandedStates) {\n                  return `conditionalGroup([${doc2.expandedStates.map((part) => printDoc(part)).join(\",\")}]${options})`;\n                }\n                return `group(${printDoc(doc2.contents)}${options})`;\n              }\n              if (doc2.type === \"fill\") {\n                return `fill([${doc2.parts.map((part) => printDoc(part)).join(\", \")}])`;\n              }\n              if (doc2.type === \"line-suffix\") {\n                return \"lineSuffix(\" + printDoc(doc2.contents) + \")\";\n              }\n              if (doc2.type === \"line-suffix-boundary\") {\n                return \"lineSuffixBoundary\";\n              }\n              if (doc2.type === \"label\") {\n                return `label(${JSON.stringify(doc2.label)}, ${printDoc(doc2.contents)})`;\n              }\n              throw new Error(\"Unknown doc type \" + doc2.type);\n            }\n            function printGroupId(id) {\n              if (typeof id !== \"symbol\") {\n                return JSON.stringify(String(id));\n              }\n              if (id in printedSymbols) {\n                return printedSymbols[id];\n              }\n              const prefix = String(id).slice(7, -1) || \"symbol\";\n              for (let counter = 0; ; counter++) {\n                const key = prefix + (counter > 0 ? ` #${counter}` : \"\");\n                if (!usedKeysForSymbols.has(key)) {\n                  usedKeysForSymbols.add(key);\n                  return printedSymbols[id] = `Symbol.for(${JSON.stringify(key)})`;\n                }\n              }\n            }\n          }\n          module2.exports = {\n            printDocToDebug\n          };\n        }\n      });\n      init_define_process();\n      module.exports = {\n        builders: require_doc_builders(),\n        printer: require_doc_printer(),\n        utils: require_doc_utils(),\n        debug: require_doc_debug()\n      };\n    }\n  });\n  return require_doc_js_umd();\n});","import { builders as b } from \"prettier/doc\";\nimport { Expression, ProductionRule } from \"@mkbabb/parse-that/ebnf\";\nimport prettier, { AST, AstPath, Doc, Options, Printer, util } from \"prettier\";\n\nfunction print(node: Expression): Doc {\n    const innerPrint = () => {\n        switch (node.type) {\n            case \"literal\":\n                if (node.value === '\"') {\n                    return b.group([\"'\", node.value, \"'\"]);\n                }\n                const s = node.value;\n                return b.group(['\"', s, '\"']);\n            case \"nonterminal\":\n                return node.value;\n            case \"epsilon\":\n                return \"\";\n            case \"group\":\n                return b.group([\"( \", b.indent(print(node.value)), b.softline, \" )\"]);\n            case \"regex\":\n                return b.group([\"/\", node.value.source, \"/\", node.value.flags]);\n            case \"optional\":\n                return b.group([print(node.value), \"?\"]);\n            case \"optionalWhitespace\":\n                return b.group([print(node.value), \"?w\"]);\n            case \"minus\":\n                return b.group([print(node.value[0]), \" - \", print(node.value[1])]);\n            case \"many\":\n                return b.group([print(node.value), \"*\"]);\n            case \"many1\":\n                return b.group([print(node.value), \"+\"]);\n            case \"skip\":\n                return b.group([print(node.value[0]), \" << \", print(node.value[1])]);\n            case \"next\":\n                return b.group([print(node.value[0]), \" >> \", print(node.value[1])]);\n            case \"concatenation\": {\n                const delim = \" , \";\n                return b.group([\n                    b.indent([\n                        b.softline,\n                        b.join(\n                            [b.conditionalGroup([b.softline]), delim],\n                            node.value.map((x) => print(x))\n                        ),\n                    ]),\n                ]);\n            }\n            case \"alternation\": {\n                const delim = \" | \";\n                return b.group([\n                    b.indent([\n                        b.softline,\n\n                        b.join(\n                            [b.conditionalGroup([b.softline]), delim],\n                            node.value.map((x) => print(x))\n                        ),\n                    ]),\n                ]);\n            }\n        }\n    };\n\n    const s = innerPrint();\n    if (node.comment) {\n        const left = node.comment.left.length ? node.comment.left + \" \" : \"\";\n        const right = node.comment.right.length ? \" \" + node.comment.right : \"\";\n        return b.group([left, s, right]);\n    }\n\n    return s;\n}\n\nexport function EBNFPrint(path: AstPath, options: Options): Doc {\n    const node = path.getValue() as AST;\n    if (!node) {\n        return \"\";\n    }\n\n    options.printWidth = 66;\n\n    const d = b.join(\n        b.hardline,\n        [...node.entries()].map(([name, rule]: [string, ProductionRule]) => {\n            const { expression, comment } = rule;\n\n            const line = [name, \" = \", print(expression), \" ;\"];\n            const above = comment.above.length\n                ? [b.join(b.hardline, comment.above), b.hardline]\n                : [];\n            const below = comment.below.length\n                ? [b.join(b.hardline, comment.below)]\n                : [];\n\n            const commentedLine = b.group([above, line, \" \", b.lineSuffix(below)]);\n\n            if (\n                expression.type === \"concatenation\" ||\n                expression.type === \"alternation\"\n            ) {\n                return b.group([commentedLine, b.hardline]);\n            }\n            return commentedLine;\n        })\n    );\n\n    return d;\n}\n","import { locStart, parse, preprocess, locEnd } from \"./parser\";\nimport { EBNFPrint } from \"./printer\";\n\nimport prettier, { Plugin } from \"prettier\";\n\nexport const languages = [\n    {\n        name: \"EBNF\",\n        since: \"0.1\",\n        parsers: [\"ebnf\"],\n        extensions: [\".ebnf\"],\n        tmScope: \"ebnf.ebnf\",\n        aceMode: \"text\",\n        linguistLanguageId: 666,\n        vscodeLanguageIds: [\"ebnf\"],\n    },\n];\n\nconst printers = {\n    ebnf: {\n        print: EBNFPrint,\n    },\n};\n\nconst parsers = {\n    ebnf: {\n        parse,\n        astFormat: \"ebnf\",\n        locStart,\n        locEnd,\n        preprocess,\n    },\n};\n\nconst defaultOptions = {\n    ebnf: {\n        printWidth: 66,\n        tabWidth: 4,\n        useTabs: false,\n    },\n};\n\nexport const EBNFPlugin = {\n    languages,\n    printers,\n    parsers,\n    defaultOptions,\n} as Plugin;\n\nexport const formatEBNF = (grammar: string, options?) => {\n    return prettier.format(grammar, {\n        parser: \"ebnf\",\n        plugins: [EBNFPlugin],\n        ...defaultOptions,\n        ...(options ?? {}),\n    });\n};\n","import { Parser } from \"@mkbabb/parse-that\";\nimport * as vscode from \"vscode\";\n\nvscode.window.showInformationMessage(\"Vibes!\");\n\nimport { formatEBNF } from \".\";\n\nexport async function activate(context: vscode.ExtensionContext) {\n    const diagnosticCollection = vscode.languages.createDiagnosticCollection(\"bbnf\");\n    diagnosticCollection.clear();\n\n    const vibes = vscode.commands.registerCommand(\"extension.vibes\", () => {\n        vscode.window.showInformationMessage(\"Vibes!\");\n    });\n    context.subscriptions.push(vibes);\n\n    const BBNFFileSelector = { language: \"bbnf\", scheme: \"file\" };\n\n    const formatBBNF = vscode.languages.registerDocumentFormattingEditProvider(\n        BBNFFileSelector,\n        {\n            provideDocumentFormattingEdits(\n                document: vscode.TextDocument\n            ): vscode.TextEdit[] {\n                if (document.getText().length === 0) {\n                    return [];\n                }\n\n                try {\n                    const formatted = formatEBNF(document.getText());\n\n                    diagnosticCollection.set(document.uri, []);\n\n                    return [\n                        vscode.TextEdit.replace(\n                            new vscode.Range(\n                                document.positionAt(0),\n                                document.positionAt(document.getText().length)\n                            ),\n                            formatted\n                        ),\n                    ];\n                } catch (e) {\n                    const { message, cause } = e;\n                    const parser = cause as Parser;\n\n                    const state = parser.state;\n\n                    const lineNumber = state.getLineNumber();\n                    const columnNumber = state.getColumnNumber();\n\n                    console.error(e);\n\n                    const diagnostic = new vscode.Diagnostic(\n                        new vscode.Range(\n                            lineNumber,\n                            columnNumber,\n                            lineNumber,\n                            columnNumber + 1\n                        ),\n                        \"Error parsing BBNF\",\n                        vscode.DiagnosticSeverity.Error\n                    );\n\n                    diagnosticCollection.set(document.uri, [diagnostic]);\n\n                    return [];\n                }\n            },\n        }\n    );\n    context.subscriptions.push(formatBBNF);\n}\n"],"names":["__defProp","__defNormalProp","__publicField","docExports","doc","module","exports","exports2","module2","__defProp2","__getOwnPropDesc","exports22","module22","defaultOptions","print","parsers","all","group","regex","string","doc2","whitespace","b","s","vscode"],"mappings":"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"}